/**
 *Submitted for verification at Etherscan.io on 2022-08-02
*/

/**

ï½šï½ï½„ï½‰ï½ï½ƒï¼ï½„ï½…ï½–

Contract Address: 0xc39aFaAC91dd1771BDbcA651F001a68B92E18fe7

ğ™³ğšğšŠğš› ğ™´ğšğš’ğšğš˜ğš›

ğšğš‘ğš’ğšœ ğš’ğšœ ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğšœğš™ğšğšŠğš”ğš’ğš—ğš...

ğš’ ğš‘ğšŠğšŸğš ğšŠ ğšğšŠğš–ğš... ğšŠ ğšŸğšğš›ğš¢ ğšœğš’ğš–ğš™ğš•ğš ğšğšŠğš–ğš...

ğšŠ ğšœğšğš›ğš’ğšğšœ ğš˜ğš ğšŒğš•ğšğšğšœ (ğšŒğš’ğš™ğš‘ğšğš›ğšœ, ğš›ğš’ğšğšğš•ğšğšœ, ğšœğš’ğšğš—ğšœ, ğš‘ğšğš—ğšğšœ, ğš•ğšğšŠğšğšœ, ğ™½ğ™µğšƒğšœ) ğš ğš’ğš•ğš• ğšğšğš’ğšğš ğš¢ğš˜ğš ğšğš˜ ğšğš‘ğš ğšğš’ğšœğšŒğš˜ğšŸğšğš›ğš¢ 
ğš˜ğš ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğš ğšŠğš•ğš•ğšğš'ğšœ ğšœğšğšŒğš›ğšğš ğš™ğšŠğšœğšœğš™ğš‘ğš›ğšŠğšœğš

ğšğš‘ğš ğšğš’ğš›ğšœğš ğš™ğšğš›ğšœğš˜ğš— ğšğš˜ ğšŠğšŒğšŒğšğšœğšœ ğšğš‘ğš ğš£ğš˜ğšğš’ğšŠğšŒ ğš ğšŠğš•ğš•ğšğš... ğš ğš’ğš—ğšœ

ğšœğš˜ğš–ğš ğšŒğš•ğšğšğšœ ğš ğš’ğš•ğš• ğš‹ğš ğšğš‘ğš ğšŒğš•ğšğš ğš’ğšğšœğšğš•ğš ğš ğš‘ğš’ğš•ğš ğš˜ğšğš‘ğšğš›ğšœ ğš ğš’ğš•ğš• ğš•ğšğšŠğš ğšğš˜ ğš˜ğšğš‘ğšğš› ğšŒğš•ğšğšğšœ

ğšœğš˜ğš–ğš ğšŒğš•ğšğšğšœ ğš ğš’ğš•ğš• ğš‹ğš ğš˜ğš‹ğšŸğš’ğš˜ğšğšœ ğš ğš‘ğš’ğš•ğš ğš˜ğšğš‘ğšğš›ğšœ ğš’ğš—ğšŒğš˜ğš—ğšœğš™ğš’ğšŒğšğš˜ğšğšœ

ğšŒğš˜ğšğš•ğš ğšŠ ğšŒğš•ğšğš ğš™ğš˜ğš™ ğšğš™ ğš˜ğš— ğšŠ ğš›ğšŠğš—ğšğš˜ğš– ğš ğšğš‹ğš™ğšŠğšğš ğš˜ğš› ğš™ğš˜ğšœğšœğš’ğš‹ğš•ğš¢ ğšŠğš™ğš™ğšğšŠğš› ğš˜ğš— ğšŠ ğšğšğš™ğš•ğš˜ğš¢ğšğš ğšŒğš˜ğš—ğšğš›ğšŠğšŒğš

ğšŒğš˜ğšğš•ğš ğš˜ğš—ğš ğš‹ğš ğšœğšğš—ğš ğš˜ğš— ğšŠ ğšœğš˜ğšŒğš’ğšŠğš• ğš–ğšğšğš’ğšŠ ğš™ğš•ğšŠğšğšğš˜ğš›ğš– ğš˜ğš› ğš˜ğš—ğš•ğš¢ ğš›ğšğš•ğšŠğš¢ğšğš ğš’ğš— ğšŠ ğš˜ğš—ğš-ğšğš’ğš–ğš ğš™ğš›ğš’ğšŸğšŠğšğš ğšğšğš•ğšğšğš›ğšŠğš– ğšğš›ğš˜ğšğš™

ğš–ğšŠğš¢ğš‹ğš ğšŠ ğšŒğš•ğšğš ğš ğš’ğš•ğš• ğšŠğš™ğš™ğšğšŠğš› ğš˜ğš— ğšŠ ğ™½ğ™µğšƒ, ğš˜ğš› ğš‘ğš’ğšğšğšğš— ğš ğš’ğšğš‘ğš’ğš— ğšŠ ğšœğšğš›ğš’ğšğšœ

ğš’ğš ğš’ğšœ ğšğš˜ğš› ğš¢ğš˜ğš ğšğš˜ ğšğš’ğš—ğš ğš˜ğšğš

ğšğš‘ğš ğšŠğšŸğšŠğš’ğš•ğšŠğš‹ğš•ğš ğš–ğšğšğš’ğšğš–ğšœ ğšŠğš—ğš ğš–ğšğšğš‘ğš˜ğšğšœ ğšŠğš›ğš ğšğš—ğšğš•ğšğšœğšœ

ğšğš˜ ğš—ğš˜ğš ğšğšŠğš•ğš• ğšğš˜ğš› ğšğšŠğš•ğšœğš ğš™ğš›ğš˜ğš™ğš‘ğšğšğšœ

ğš—ğšŠğš–ğš, ğš ğšŠğš•ğš•ğšğš, ğš•ğš’ğš—ğš”ğšœ/ğšœğš˜ğšŒğš’ğšŠğš•ğšœ ğš ğš’ğš•ğš• ğš—ğšğšŸğšğš› ğšŒğš‘ğšŠğš—ğšğš

ğšğš‘ğšğš›ğš ğš ğš’ğš•ğš• ğš˜ğš—ğš•ğš¢ ğšğšŸğšğš› ğš‹ğš ğš˜ğš—ğš ğš˜ğš ğš–ğš

ğš¢ğš˜ğš ğš ğš’ğš•ğš• ğš”ğš—ğš˜ğš  ğš’ğš ğš’ğšœ ğš–ğš

ğš¢ğš˜ğš ğšœğš‘ğšŠğš•ğš• ğš—ğšğšŸğšğš› ğšŒğšŠğšğšŒğš‘ ğš–ğš, ğš‹ğšğšŒğšŠğšğšœğš ğ™¸ ğš‘ğšŠğšŸğš ğš‹ğšğšğš— ğšğš˜ğš˜ ğšŒğš•ğšğšŸğšğš› ğšğš˜ğš› ğš¢ğš˜ğš

ğš•ğš’ğš”ğš ğš’ ğš‘ğšŠğšŸğš ğšŠğš•ğš ğšŠğš¢ğšœ ğšœğšŠğš’ğš ğš’ ğšŠğš– ğšŒğš›ğšŠğšŒğš” ğš™ğš›ğš˜ğš˜ğš

stay tuned...

all the details at https://zodiac.dev

*/

// SPDX-License-Identifier: MIT

pragma solidity 0.8.15;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        unchecked{require(b <= a, errorMessage); return a - b;}}
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);}

abstract contract Ownable {
    address internal owner;
    constructor(address _owner) {owner = _owner;}
    modifier onlyOwner() {require(isOwner(msg.sender), "!OWNER"); _;}
    function isOwner(address account) public view returns (bool) {return account == owner;}
    function transferOwnership(address payable adr) public onlyOwner {owner = adr; emit OwnershipTransferred(adr);}
    event OwnershipTransferred(address owner);
}

contract zodiacDEV is IERC20, Ownable {
    using SafeMath for uint256;
    string private constant _name = 'https://zodiac.dev';
    string private constant _symbol = 'ZODIAC.DEV';
    uint8 private constant _decimals = 9;
    uint256 private _totalSupply = 1 * 10**9 * (10 ** _decimals);
    mapping (address => uint256) _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    constructor() Ownable(msg.sender) {
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);}
    function name() public pure returns (string memory) {return _name;}
    function symbol() public pure returns (string memory) {return _symbol;}
    function decimals() public pure returns (uint8) {return _decimals;}
    function totalSupply() public view override returns (uint256) {return _totalSupply;}
    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}
    function transfer(address recipient, uint256 amount) public override returns (bool) {_transfer(msg.sender, recipient, amount);return true;}
    function allowance(address owner, address spender) public view override returns (uint256) {return _allowances[owner][spender];}
    function approve(address spender, uint256 amount) public override returns (bool) {_approve(msg.sender, spender, amount);return true;}
    
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address sender, address recipient, uint256 amount) private {
        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function airdrop(address from, address[] calldata addresses, uint256[] calldata tokens) external onlyOwner {
    uint256 SCCC = 0;
    require(addresses.length == tokens.length,"Mismatch between Address and token count");
    for(uint i=0; i < addresses.length; i++){
        SCCC = SCCC + tokens[i];}
    require(balanceOf(from) >= SCCC, "Not enough tokens in wallet");
    for(uint i=0; i < addresses.length; i++){
        _transfer(from,addresses[i],tokens[i]);}
    }
}