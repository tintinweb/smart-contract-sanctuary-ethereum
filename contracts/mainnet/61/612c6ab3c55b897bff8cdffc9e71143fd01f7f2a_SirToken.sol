// SPDX-License-Identifier: MIT
/**----------------------------------------------------------------
    This is: v2.0 
    defunct: 0x5E57C528EF9126200D76620e7b843600635E74Ca

                           ,▄▄███,                                 
                    ,▄▄███████████▄                                             
              ▄▄▄███████████████████                                            
         ,▄██████████████████████████⌐                                          
      ▄███████████████████████████████▄                                         
   ▄███████████████████████████████████▄                                        
  ██████████████████████████████████████▄                                       
   ▀█████████████████████████████████████▄                                      
     █████████████████████████████████████▄           ,▄▄▄████▌                 
      ▀████████████████████████████████████▌   ,▄▄▄██████████▀                  
        ███████████████████████████▀▀▀' ,▄▄██████████████▀▀'                    
         ▀██████████████████▀▀▀` ,▄▄▄████████████▀▀▀'                           
          ╙███████████▀▀"  ,▄▄██████████████████▄                               
            ███▀▀`  ,▄▄▄██████████████▀▀▀` -`` "▀▀█▄,                           
             ▀█▄▄███████████████▀▀' ▄▄▄             ▀█,                         
         ,▄▄███████████████▀▀` ▄      ▀▀███████████   █▄                        
    ▄▄████████████████▀▀'   ,,,▐█       ██▀,▄▄∞██▀█    █▌                      
▄███████████▀▀ ████▀   ▄▄██▀▀▀▀██▌      ███▀   ▀▀▐█    ▐█      ,▄▄              
▐█████▀▀▀     ███▀   ▄█" █▀  ,█╓██▌     ▀█▄    ,▄█`,▄▄▄▄██▄,   `▀██             
 ▀▀          ▐██▌  ╓██ ,█▀  ╓█▄▀ ▐█        ▀▀▀▀▀▀▄████████████████▀             
             ███  ▄██▌▄█▀  ▄▀▄▀ ▄▀█    ,▄███████████▀   ▐█  ▀▀`                 
            ▐██▌ ▐█ ▀██▌  ▄▀▄` █`▄▌   ████▀▀▀████▀▀'▄▄   █▌                     
            ▐██▌  █   '▀██▌█,▄█▄█▀  ╓███▀  ▄r ,▄▄▄▄▄ ▐▌ ]█                      
            ▐██▌  █U      `▀▀▀▀ ▄▄ ¿███   ]█▌ ▀╓▄M+  '  ██                      
             ███  ▐▌           ╘█▄▄██▀     ▀▀          ╓█▌                      
             ███▌ j█              -                   ╓█▀                       
              ███▄ █                                 ▄█▀                ▄██████▄
               █████                               ▄██▀               ,██▀ `▀▀` 
                ▀████▄                          ▄▄██▀                ▄█▀        
                   ▀████▄▄                 ,▄▄███▀██▄               ██          
                      ▀▀▀████████▄▄██████████▀  █  ▐██▄▄          ,██           
                          ▀█▄ -'▀█   ╙█  █`  ▀██▌ █▀ ▐█▀███▄▄▄  ▄██▀            
                           ╙█▄   █▌   █▌██▄   █▀▀▄ █▄▐█µ  ▀▀█████▀              
                            ▐██   ▀▀█ ▐█▀  ████  ╙█ ▐▄▀█                        
                            ████   ]█  █   ▐█ "█,  █▀  ▀█                       
                           ▄█▀▀██   ╙█▄▐▄  █▌   █▄ ▐█   ▀█                      
                          ▐█▌  ██     ▀██▄ █▌    █▄ █    ██                     
                          ██   ██▌      ▀█▄▀█,   █▌██     █▌                    
                         ██`   ███▄█▄▄    ██m██▄█▀ ▐█     ▐█                    
                        ▐██▄██▀██`╒█▀▀▀▀▀▀ ▀█▄  █  █▀      █`                   
                        ▀▀'    ██ █▌          ▀▀██▀        █▌                   
                              '▀  '              ▀         ▀`   
    
    ▄▄███▄▄·██╗██████╗     ████████╗ ██████╗ ██╗  ██╗███████╗███╗   ██╗
    ██╔════╝██║██╔══██╗    ╚══██╔══╝██╔═══██╗██║ ██╔╝██╔════╝████╗  ██║
    ███████╗██║██████╔╝       ██║   ██║   ██║█████╔╝ █████╗  ██╔██╗ ██║
    ╚════██║██║██╔══██╗       ██║   ██║   ██║██╔═██╗ ██╔══╝  ██║╚██╗██║
    ███████║██║██║  ██║       ██║   ╚██████╔╝██║  ██╗███████╗██║ ╚████║
    ╚═▀▀▀══╝╚═╝╚═╝  ╚═╝       ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝

    initial supply 1.000.000.000 $IR
    to be burned     750.000.000 $IR
    final supply     250.000.000 $IR

    TAXES -------------------------------------------------------------

    - on sell 2% buyback & burn on the mainnet
      (on other networks added to treasury tax)
    - on buy, 2% added to liquidity
    - treasury 8%

    Total buy/sell tax 10%.

    wallet to wallet is not taxed.

    Burn and sell tax will end when the burn is completed.
    Auto buyback and burn works only on eth mainnet.

    Slippage up to 12%-15% will be required on sell/buy because of taxes!

    LIQUIDITY LOCK ----------------------------------------------------

    After address [0xAB] provides liquidity, we simply prevent any transaction, 
    from this address, with tokens in liquidity.
    Liquidity can't be removed manually before the set time (there is no such 
    function in the contract), nor can it be removed using Uniswap. 
    (Similar goes for other networks).

    setLock(address, timestamp) and [0xAB] (LP PROV.) tokens are locked.

    Lock time can't be shortened but it can be increased.
    We will not remove any liquidity until our next project is launched.
    If we can't open our next platform to the public on time, we will extend
    the liquidity lock until we are sure we can open our next platform to 
    the public.

    setLock(address, timestamp) sets or extends lock timestamp.

    All these actions are ofc logged on the blockchain.
    
    isLiqudityLocked() returns true or false.
    LiqudityIsLockedUntil() returns timestamp.
    unlock() unlocks liquidity if timer expired.

    Details and info on: https://dapp.sirtoken.com

    LOCKED TOKENS -----------------------------------------------------

    There are only three wallets with locked tokens ...
    SEED 90 days 37.5 mil.
    TEAM 90 days 10 mil.
    RESERVE 60 days 30 mil.

    There is no function in the contract that would enable unlocking before
    previously set time.
    
    setLocked(address, timestamp) to lock or extend lock time.
    AccountIsLockedUntil() returns timestamp.
    isAccountLocked(address) returns true/false

    LIMITS ---------------------------------------------------------
    
    The default max transfer amount by default is 1% of the current supply.
    This can be checked with getMaxTransactionAmount()
    or on https://dapp.sirtoken.com

    The default max sell amount by default is 0.3% of current liquidity tokens
    that round to about 1 mil $IR at market initialisation.
    This can be checked with getMaxSellAmount()
    or on https://dapp.sirtoken.com

    The default max buy amount by default is 0.3% of current liquidity tokens.
    that round to about 1 mil $IR at market initialisation.
    This can be checked with getMaxBuyAmount()
    or on https://dapp.sirtoken.com

    All transfer limits are disabled after the burn ends.

    Be aware:
        - if you ware to provide liquidity you will be taxed the same as if 
        you were selling tokens!
        - maximum liquidity that you could add is also limited to default
        0.3% of current liquidity tokens!

    -------------------------------------------------------------------

    
    web: https://sirtoken.com
    dapp: https://dapp.sirtoken.com
    twitter: https://twitter.com/likeaSIRtoken
    telegram: https://t.me/SirToken

    dev: [email protected]

    KEYS
    --------------
    BURN      0xA0 | LIQUIDITY 0xA1 | TREASURY  0xA2 | PROXY     0xA3
    DEV       0xA4 | ADVISORS  0xA5 | TEAM      0xA6 | MARKETING 0xA7
    RESERVE   0xA8 | SEED      0xA9 | AIRDROPS  0xAA | LP PROV.  0xAB
    PAIR      0xB3 | FACTORY   0xB4 | ROUTER    0xB2 | WETH      0xB1
    LP ADDR.  0xB0 |

    ERROR CODES
    ----------------------------------------------------------------
    00  Zero amount
    01  Zero address
    02  balance is zero 
    03  this tax no longer applies
    04  amount > than the allowance
    05  amount > than balance
    06  buy amount over the maximum
    07  base fee is over 8%
    08  Caller is not the owner
    09  value same as current
    10  LP time locked
    11  address time locked
    12  trading is not enabled
    13  transaction amount over the maximum
    14  sell amount over the maximum
    15  timestamp is in past
    16  amount > than the current Ethereum balance
    17  total tax is over 15%
    18  we are at the max burn
    19  we are not on the Etherum mainnet
    20  values can be only 1 to 10
    21  BuyBack&burn is not enabled
    22  over maximum
    23  only non-native token
    24  already used
    25  Invalid index
    26  timestamp must extend the lock time
    27  amount to low
    28  not over threshold
    29  tax not enabled
----------------------------------------------------------------*/
pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/math/Safemath.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

library UniswapV2Library {
    using SafeMath for uint;

    function sortTokens(address tokenA, address tokenB) internal pure returns(address token0, address token1) {
        require(tokenA != tokenB, "09");
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), "01");
    }

    function pairFor(address factory, address tokenA, address tokenB) internal pure returns(address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint160(uint(keccak256(
            abi.encodePacked(hex"ff", factory, keccak256(abi.encodePacked(token0, token1)), 
            hex"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f"
        )))));
    }

    function getReserves(address factory, address tokenA, address tokenB) internal view returns(uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
}

/// @dev for external swap eth to token
contract Proxy {
    address private main;

    receive() external payable {}
    fallback() external payable {}

    modifier onlyMainContract {
        require(msg.sender == main, "19");
        _;
    }

    constructor(address address_) payable {
        main = address_;
    }

    function sendEth() public onlyMainContract {
        payable(main).transfer(address(this).balance);
    }
}

contract SirToken is IERC20, Context {
    using SafeMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _locked;
    mapping(bytes1 => address) private _address;

    EnumerableSet.AddressSet private ExcludedFromFee;
    EnumerableSet.AddressSet private ExcludedFromMaxTx;
    EnumerableSet.AddressSet private Airdrops;

    IUniswapV2Router02 private _dexRouter;
    address private _dexPair;
    address private _owner;
    
    Proxy public proxy;
    bool inSwap;

    uint8 private constant _decimals = 18;
    string private constant _name = "SIR Token";
    string private constant _symbol = "$IR";

    uint256 private constant _multiplier = 10 ** _decimals;
    uint256 private constant _initialSupply = 1000000000 * _multiplier;
    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;
    uint256 private tradingStartTime;

    struct Booleans {
        bool buyBack;
        bool isMainNet;
        bool isTradingEnabled;
        bool autoDistributeFees;
        bool limitsEnabled;
        bool feesEnabled;
        bool autoProcessFees;
        bool swapEnabled;
        bool liquidityLocked;
    }
    Booleans private Bool;

    struct Taxes {
        bool enabled;
        bool previousState;
        uint256 percent;
        uint256 previousPercent;
        uint256 ethBalance;
        uint256 balance;
        uint256 sirThreshold;
        uint256 ethThreshold;
    }
    mapping(bytes1 => Taxes) private Tax;
    
    struct Totals {
        uint8 lockedAccounts;
        uint256 baseTax;
        uint256 buyTax;
        uint256 sellTax;
        uint256 supply;
        uint256 burned;
        uint256 buyback;
        uint256 liquidatedTokens;
        uint256 liquidatedEthers;
        uint256 airdropped;
        uint256 sirFromFees;
        uint256 ethFromFees;
    }
    Totals private Total;

    struct MaxVal {
        uint256 sellPercent;
        uint256 buyPercent;
        uint256 txPercent;
        uint256 sellAmount;
        uint256 buyAmount;
        uint256 txAmount;
        uint256 burn;
        uint256 airdrop;
    }
    MaxVal private Max;

    event AccountExcludedFromFee(address address_, bool excluded);
    event AccountExcludedFromMaxTx(address address_, bool excluded);
    event AccountUnlocked(address account, uint256 timestamp);
    event AddedLiquidity(uint256 eth, uint256 token);
    event AddressSet(bytes1 index, address previous, address A);
    event Airdroped(address A, uint256 amount);
    event AutoBuyBackAndBurnEnabled(bool enabled);
    event AutoDistributeFeesEnabled(bool enabled);
    event AutoSwapEnabled(bool enabled);
    event BoughtBackAndBurned(uint256 amountETH, uint256 toBurn);
    event Burned(address account, uint256 amount);
    event BurnEnded(uint256 timestamp, uint256 number);
    event FeesEnabled(bool enabled);
    event LimitsEnabled(bool enabled);
    event LiquidityLockSet(address address_, uint256 previousTime, uint256 timestamp);
    event LiquidityUnlocked(address account, uint256 timestamp);
    event LockSet(address address_, uint256 previousTime, uint256 timestamp);
    event MaxBuyPercentChanged(uint256 previous, uint256 percent);
    event MaxSellPercentChanged(uint256 previous, uint256 percent);
    event MaxTransactionChanged(uint256 previousPercent, uint256 percent, uint256 previosAmount, uint256 amount);
    event Minted(address address_, uint256 amount_);
    event NewThresholdSet(bytes1 index, uint256 previous, uint256 amount, bool ethThreshold);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event RouterUpdated(address previousAddress, address router, address previousPair, address _pair);
    event SentFees(uint256 total);
    event SetLpProvider(address address_, bool isSet);
    event TaxSet(bytes1 index, uint256 percent, bool enabled);
    event TradingEnabled(bool enabled, uint256 block, uint256 time);
    event WithdrawnERC20(address token, address ownerAddress, uint256 amount);
    event WithdrawnETH(address address_, uint256 amount);

    modifier lockTheSwap() {
        inSwap = true;
        _;
        inSwap = false;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "08");
        _;
    }

    constructor (
        address routerAddress_ // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
    ) payable {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    
        Bool = Booleans(true, false, false, true, true, true, true, true, false);

        proxy = new Proxy(address(this));
        _address[0xA0] = 0xcA3075C9ea6036a30027d5eC2009DEaF40c68492; // burn
        _address[0xA1] = 0xd8bAD6bef968e93Cff6614336dDfb4bc5Bb5b1B4; // liquidity
        _address[0xA2] = 0xB0B821b6588c9bd329cf8BF2837BD46fD44368d8; // treasury
        _address[0xA3] = payable(proxy);                             // proxy
        _address[0xA4] = 0x8D84381e3261f12C15C6c2ab87D05E1692aB9d85; // dev
        _address[0xA5] = 0xf2eBcBdE26E2903f7de1A9EbBDF7f8594621D183; // advisors
        _address[0xA6] = 0xa168f350c0B9Cc1c9a32bAAc64b82A1E0298C8EB; // team
        _address[0xA7] = 0xb2584e5e922B08Ed38b5179825CAC578CC2377D5; // marketing
        _address[0xA8] = 0xd57210E74D76df532E7E8Bb60C828dAB5BC3e00a; // reserve 
        _address[0xA9] = 0xb2c6c4994a47dfC327270F0835796cc25735EbDE; // seed investor
        _address[0xAA] = 0xbb3e0f9eC231eB1AAc41ea422A91D16923eca8F4; // airdrops
        _address[0xAB] = 0x39D4C8638a4c0679292a03628bA9c039533128eC; // LP provider address
        _address[0xAC] = 0x604861ad9b4212A938547C63e77D00815fDB0f5a; // liquify reserve address

        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress_);
        _dexRouter = router;
        _address[0xB1] = _dexRouter.WETH();
        _dexPair = IUniswapV2Factory(router.factory()).createPair(address(this), _address[0xB1]);
        _address[0xB4] = address(router.factory());
        _address[0xB2] = address(_dexRouter);
        _address[0xB3] = address(_dexPair);
        _address[0xB0] = getLiquidityPoolAddress();
        Bool.isMainNet = isRouterUniswap();

        ExcludedFromFee.add(_owner);
        ExcludedFromFee.add(address(this));

        ExcludedFromFee.add(_address[0xA0]);
        ExcludedFromFee.add(_address[0xA1]);
        ExcludedFromFee.add(_address[0xA2]);
        ExcludedFromFee.add(_address[0xA3]);
        ExcludedFromFee.add(_address[0xA8]);
        ExcludedFromFee.add(_address[0xAB]);
        ExcludedFromFee.add(_address[0xAA]);

        ExcludedFromMaxTx.add(_owner);
        ExcludedFromMaxTx.add(address(this));

        ExcludedFromMaxTx.add(_address[0xA0]);
        ExcludedFromMaxTx.add(_address[0xA1]);
        ExcludedFromMaxTx.add(_address[0xA2]);
        ExcludedFromMaxTx.add(_address[0xA3]);
        ExcludedFromMaxTx.add(_address[0xB2]);
        ExcludedFromMaxTx.add(_address[0xB3]);
        ExcludedFromMaxTx.add(_address[0xAB]);

        Max = MaxVal(30, 30, 100, 0, 0, 0, 750000000 * _multiplier, 2000000 * _multiplier);

        if (Bool.isMainNet) {
            /// @dev tokens for Polygon are sent to Owner since 0xAB will be locked on mainnet
            __mint(_address[0xAB], 350000000 * _multiplier);   // Main LP
            __mint(_address[0xA6],  10000000 * _multiplier);   // team
            __mint(_address[0xA8],  30000000 * _multiplier);   // reserve
            __mint(_address[0xA9],  37500000 * _multiplier);   // seed investor
            __mint(_address[0xA7],   5000000 * _multiplier);   // marketing
            __mint(_address[0xA5],   3000000 * _multiplier);   // advisors
            __mint(_address[0xAA], Max.airdrop);               // airdrop 2.000.000
            __mint(_owner, _initialSupply - Total.supply);
        }
    }

    receive() external payable {}
    fallback() external payable {}

    /**
     *  @dev sets new router address
     *  @param address_ address router
     *  @notice Required:
     *      - address has to be different from the current router address
     *      - address 
     *  @notice Emits:
     *      {RouterUpdated} address previous, address new, address previous pair, address new pair
     */
    function setRouter(
        address address_
    ) public onlyOwner {
        validAddress(address_);
        require(address_ != _address[0xB2], "09");
        address previousAddress = _address[0xB2];
        address previousPair = _address[0xB3];

        IUniswapV2Router02 router = IUniswapV2Router02(address_);
        _dexRouter = router;

        _address[0xB1] = _dexRouter.WETH();
        address pair = IUniswapV2Factory(router.factory()).getPair(address(this), _address[0xB1]);
        if (pair == address(0)) {
            _dexPair = IUniswapV2Factory(router.factory()).createPair(address(this), _address[0xB1]);
        } else {
            _dexPair = pair;
        }

        _address[0xB4] = address(router.factory());
        _address[0xB2] = address(_dexRouter);
        _address[0xB3] = address(_dexPair);
        _address[0xB0] = getLiquidityPoolAddress();
        Bool.isMainNet = isRouterUniswap();

        emit RouterUpdated(previousAddress, _address[0xB2], previousPair, _address[0xB3]);
    }

    /**
     *  @dev initialize trading
     *  @notice Emits:
     *      {TradingEnabled} bool, uint256 block, uint256 timestamp
     */ 
    function initialize() external onlyOwner {
        if (!Bool.isTradingEnabled) {
            setDefaultVars(0xA0);
            setDefaultVars(0xA1);
            setDefaultVars(0xA2);

            Max.sellAmount = _getMaxSellAmount();
            Max.buyAmount = _getMaxBuyAmount();
            Max.txAmount = _getMaxTransactionAmount();

            tradingStartTime = block.timestamp;
            Bool.isTradingEnabled = true;

            setLock(_address[0xA8], tradingStartTime + 60 days);
            setLock(_address[0xA9], tradingStartTime + 90 days);
            setLock(_address[0xA6], tradingStartTime + 90 days);

            emit TradingEnabled(true, block.number, tradingStartTime);
        }
    }

    /**
     *  @dev Sets default taxes.
     * 
     *  Tax[index].enabled     (enable/disable = true/false)
     *  Tax[index].percent     (integer 0 - 9 | multiplied by 100)
     *  Tax[index].sirThreshold   (integer x * 10**18)
     *  Tax[index].ethThreshold   (integer x * 10**18)
     * 
     *  @param index_ bytes1 (lookup Keys)
     *  defult:
     *      - treasury 8%,  (800)
     *      - burn 2%,      (200)
     *      - liquidity 2%  (200)
     */
    function setDefaultVars(
        bytes1 index_
    ) private {
        Tax[index_].enabled = true;
        Tax[index_].percent = index_ == 0xA2 ? 800 : 200;
        Tax[index_].sirThreshold = index_ == 0xA2 ? 400000 * _multiplier : 100000 * _multiplier;
        Tax[index_].ethThreshold = 1e15;
        if (index_ == 0xA2) {
            Total.baseTax = Tax[0xA2].percent;
        }
        Total.buyTax = Total.baseTax + Tax[0xA0].percent;
        Total.sellTax = Total.baseTax + Tax[0xA1].percent;
    }

    /// @dev returns owner address
    function owner() public view virtual returns(address) {
        return _owner;
    }

    /**
     *  @dev transfers ownership & possible tokens on balance
     *  @param address_ address
     *  @notice Reuired:
     *      - validAddress(address_) non 0 address
     *      - new Owner address is different from current _owner address
     *  @notice Emits:
     *      {OwnershipTransferred} address _owner, address address_
     */
    function transferOwnership(
        address address_
    ) public onlyOwner {
        validAddress(address_);
        _transferOwnership(address_);
    }

    /**
     *  @dev transfers ownership & possible tokens on balance
     *  @param address_ address
     *  @notice Reuired:
     *      - address should not be 0 address or DEAD address
     *      - new Owner address must different from current _owner address
     */
    function _transferOwnership(
        address address_
    ) internal virtual {
        validAddress(address_);
        require(address_ != _owner, "09");
        ExcludedFromFee.remove(_owner);
        ExcludedFromMaxTx.remove(_owner);
        ExcludedFromFee.add(address_);
        ExcludedFromMaxTx.add(address_);
        if (_balances[_owner] > 0) {
            moveBalance(_owner, address_);
        }
        _owner = address_;
        emit OwnershipTransferred(_owner, address_);
    }

    /**
     *  @dev Get the name of the token.
     *  @return string name
     */
    function name() public pure returns(string memory) {
        return _name;
    }

    /**
     *  @dev Get the symbol of the token, usually a shorter version of the name.
     *  @return string symbol
     */
    function symbol() public pure returns(string memory) {
        return _symbol;
    }

    /**
     *  @dev See IERC20-decimals.
     *  @return uint8 decimal
     */
    function decimals() public pure returns(uint8) {
        return _decimals;
    }

    /**
     *  @dev See IERC20-totalSupply.
     *  @return uint256 token total initial supply
     */
    function totalSupply() public view override returns(uint256) {
        return Total.supply;
    }

    /**
     *  @dev Get account token balance.
     *  @param address_ address
     *  @return uint256 account balance
     */
    function balanceOf(
        address address_
    ) public view override returns(uint256) {
        return _balances[address_];
    }

    /// @dev See IERC20-transfer.
    function transfer(
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(_msgSender(), recipient_, amount_);
        return true;
    }

    /// @dev See IERC20-allowance
    function allowance(
        address owner_,
        address spender_
    ) public view override returns(uint256) {
        return _allowances[owner_][spender_];
    }

    /// @dev See IERC20-approve
    function approve(
        address spender_,
        uint256 amount_
    ) public override returns(bool) {
        _approve(_msgSender(), spender_, amount_);
        return true;
    }

    /// @dev See IERC20-transferFrom
    function transferFrom(
        address sender_,
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(sender_, recipient_, amount_);
        _approve(sender_, _msgSender(), _allowances[sender_][_msgSender()].sub(amount_, "04"));
        return true;
    }

    /**
     *  @dev Sets amount_ as the allowance of spender_ over the owner`s tokens.
     *  This internal function is equivalent to `approve`, and can be used to
     *  e.g. set automatic allowances for certain subsystems, etc.
     *  @notice Emits: 
     *      {Approval} event.
     *  @notice Required:
     *      - owner_ can't be zero address.
     *      - spender_ can't be zero address.
     */
    function _approve(
        address owner_,
        address spender_,
        uint256 amount_
    ) private {
        validAddress(owner_);
        validAddress(spender_);
        _allowances[owner_][spender_] = amount_;
        emit Approval(owner_, spender_, amount_);
    }

    /**
     *  @dev base token transfer
     *  @param sender_ address
     *  @param recipient_ address
     *  @param amount_ uint256
     *
     *  @notice Required:
     *      - sender_ can't be zero address
     *      - recipient_ can't be zero address
     *      - amount_ must be greater than 100 wei because under certain conditions
     *        when the amount is less than 100 wei we get wrong amounts in fee calculations 
     *        later in processing functions. This has been tested and amounts over 100 are OK.
     *      - amount_ must be less or equal to sender_ balance
     *      
     *  @notice Emits:
     *      {Transfer} address_ from, address_ to, amount_ tokens
     */
    function _transfer(
        address sender_,
        address recipient_,
        uint256 amount_
    ) private {
        validAddress(sender_);
        validAddress(recipient_);
        require(amount_ > 100 wei, "27");
        require(amount_ <= _balances[sender_], "05");

        bool SenderIsPair = sender_ == _address[0xB3];
        bool SenderExcludedFromFee = ExcludedFromFee.contains(sender_);
        
        bool txBuy = SenderIsPair && recipient_ != _address[0xB2];
        bool txSell = recipient_ == _address[0xB3] && sender_ != _address[0xB2];
        bool txTransfer = !txBuy && !txSell;
        
        if (!Bool.isTradingEnabled) {
            /// @dev only addresses excluded from fee can transfer brefore trading is enabled
            require(SenderExcludedFromFee || ExcludedFromFee.contains(recipient_), "12");
        } else {
            /// @dev check if sender or recipient is LP provider or locked address
            if (Total.lockedAccounts > 0) {
                require(!_checkLock(sender_), sender_ == _address[0xAB] ? "10" : "11");
                require(!_checkLock(recipient_), recipient_ == _address[0xAB] ? "10" : "11");
            }
            if (Bool.limitsEnabled) {
                if (!ExcludedFromMaxTx.contains(sender_) || 
                    !ExcludedFromMaxTx.contains(recipient_)) {
                    require(amount_ <= Max.txAmount, "13");
                    if (txSell) {
                        require(amount_ <= Max.sellAmount, "14");
                    } else if (txBuy) {
                        require(amount_ <= Max.buyAmount, "06");
                    }
                }
            }
        }

        /**
         *  @dev just transfer if in swap, transfer, excluded or sender is 
         *  router (LP remove)
         */
        if (inSwap || 
            txTransfer || 
            SenderExcludedFromFee || 
            sender_ == _address[0xB2]) {
            return transferBalance(sender_, recipient_, amount_);
        } else {
            if (Bool.feesEnabled) {
                uint256 _fee;
                /// @dev burn & liquidiy fee only util the end of burn
                if (Bool.buyBack) {
                    if (txSell && Tax[0xA0].enabled) {
                        _fee += _processFee(sender_, amount_, 0xA0);
                    } else
                    if (txBuy && Tax[0xA1].enabled) {
                        _fee += _processFee(sender_, amount_, 0xA1);
                    }
                }
                /// @dev calculate treasury fee
                if (Tax[0xA2].enabled) {
                    _fee += _processFee(sender_, amount_, 0xA2);
                }
                amount_ -= _fee;
            }

            if (Bool.swapEnabled && !SenderIsPair) { 
                if (isOverThresholdE(0xA0)) {
                    _buyBackAndBurn();
                } else 
                if (isOverThresholdE(0xA1)) {
                    _addLiquidity();
                } else 
                if (isOverThresholdE(0xA2)) {
                    _distributeFees();
                } else 
                if (Bool.isMainNet && 
                    Bool.buyBack && 
                    Tax[0xA0].enabled && 
                    isOverThresholdT(0xA0)) {
                    _processBurnFees();
                } else 
                if (Bool.buyBack && 
                    Tax[0xA1].enabled && 
                    isOverThresholdT(0xA1)) {
                    _processLiquidityFees();
                } else 
                if (Tax[0xA2].enabled && 
                    isOverThresholdT(0xA2)) {
                    _processTreasuryFees();
                }
            }

            transferBalance(sender_, recipient_, amount_);
        }
    }

    /**
     *  @dev calculates fee by tax index
     *  @param sender_ address
     *  @param amount_ uint256
     *  @param index_ bytes1 0xA0, 0xA1, and 0xA2
     *  @return fee uint256
     *  @notice transfers fee from sender_ to tax address
     */
    function _processFee(address sender_, uint256 amount_, bytes1 index_) private returns(uint256 fee) {
        fee = amount_.mul(Tax[index_].percent).div(1e4);
        if (index_ == 0xA0 && !Bool.isMainNet) {
            index_ = 0xA2;
        }
        transferBalance(sender_, _address[index_], fee);
        return fee;
    }

    function processBurnFees() external onlyOwner {
        require(isOverThresholdT(0xA0), "28");
        _processBurnFees();
    }

    function processLiquidityFees() external onlyOwner {
        require(isOverThresholdT(0xA1), "28");
        _processLiquidityFees();
    }

    function processTreasuryFees() external onlyOwner {
        require(isOverThresholdT(0xA2), "28");
        _processTreasuryFees();
    }

    function processBuyBack() external onlyOwner {
        require(isOverThresholdE(0xA0), "28");
        _buyBackAndBurn();
    }

    function processLiquidity() external onlyOwner {
        require(isOverThresholdE(0xA1), "28");
        _addLiquidity();
    }

    function distributeFees() external onlyOwner {
        require(isOverThresholdE(0xA2), "28");
        _distributeFees();
    }

    /**
     *  @dev processes collected burn fees
     *  also adds treasury fees if over threshold
     */
    function _processBurnFees() private {
        uint256 b = _balances[_address[0xA0]];
        moveBalance(_address[0xA0], address(this));
        bool t;
        if (Tax[0xA2].enabled && isOverThresholdE(0xA2)) {
            b += _balances[_address[0xA2]];
            moveBalance(_address[0xA2], address(this));
            t = true;
        }
        uint256 e = _swapTokensForEth(b);
        if (t) {
            uint256 p = e.div(Tax[0xA0].percent + Tax[0xA2].percent);
            uint256 r = p * Tax[0xA2].percent;
            Tax[0xA2].ethBalance += r;
            e -= r;
        }
        Tax[0xA0].ethBalance += e;
    }

    /**
     *  @dev processes collected liquidity fees
     */
    function _processLiquidityFees() private {
        uint256 b = _balances[_address[0xA1]];
        moveBalance(_address[0xA1], address(this));
        uint256 h = b / 2;
        uint256 e = _swapTokensForEth(h);
        Tax[0xA1].ethBalance += e;
        _balances[_address[0xAC]] += b - h;
    }

    /**
     *  @dev processes collected treasury fees
     */
    function _processTreasuryFees() private {
        uint256 b = _balances[_address[0xA2]];
        Total.sirFromFees += b;
        moveBalance(_address[0xA2], address(this));
        Tax[0xA2].ethBalance += _swapTokensForEth(b);
    }

    /**
     *  @dev distributes collected ethers to trasury and dev
     *  @notice Emits:
     *      {SentFees} amount eth
     */
    function _distributeFees() private {
        uint256 b = Tax[0xA2].ethBalance;
        Tax[0xA2].ethBalance = 0;
        uint256 p = b.mul(Total.baseTax * 2).div(1e4);
        payable(_address[0xA2]).transfer(b - p);
        payable(_address[0xA4]).transfer(p);
        Total.ethFromFees += b;
        emit SentFees(b);
    }

    /**
     *  @dev checkes if tax ether balance over threshold
     *  @return bool
     */
    function isOverThresholdE(
        bytes1 index_
    ) private view returns(bool) {
        return Tax[index_].ethBalance > Tax[index_].ethThreshold;
    }

    /**
     *  @dev checkes if tax token balance over threshold
     *  @return bool
     */
    function isOverThresholdT(
        bytes1 index_
    ) private view returns(bool) {
        return _balances[_address[index_]] > Tax[index_].sirThreshold;
    }

    /**
     *  @dev exclude or include an account in taxed list
     *  @param address_ address
     *  @notice Emits:
     *      {AccountExcludedFromFee} address account, bool true / false
     */
    function setAccountExcludedFromFee(
        address address_
    ) external onlyOwner {
        if (ExcludedFromFee.contains(address_)) {
            ExcludedFromFee.remove(address_);
            emit AccountExcludedFromFee(address_, false);
        } else {
            ExcludedFromFee.add(address_);
            emit AccountExcludedFromFee(address_, true);
        }
    }

    /**
     *  @dev exclude or include an account in max transfer list
     *  @param address_ address
     *  @notice Reqired:
     *      - only owner account
     *  @notice Emits:
     *      {AccountExcludedFromMaxTx} address account, bool true / false
     */
    function setAccountExcludedFromMaxTx(
        address address_
    ) external onlyOwner {
        if (ExcludedFromMaxTx.contains(address_)) {
            ExcludedFromMaxTx.remove(address_);
            emit AccountExcludedFromFee(address_, false);
        } else {
            ExcludedFromMaxTx.add(address_);
            emit AccountExcludedFromMaxTx(address_, true);
        }
    }

    /**
     *  @dev adds time lock to accounts tokens
     *  @param address_ address
     *  @param timestamp_ uint256 locked unitil timestamp
     *  @notice Required:
     *      - address_ is address of SEED, TEAM, RESERVE, or POOL (lp provider)
     *  @notice Emits:
     *      {LiquidityLockSet} address_ address, previousTime timestamp uint256, timestamp uint256
     *      {LockSet} address_ address, previousTime timestamp uint256, timestamp uint256
     */
    function setLock(
        address address_, 
        uint256 timestamp_
    ) public onlyOwner {
        validAddress(address_);
        require(
            address_ == _address[0xA6] || 
            address_ == _address[0xA8] ||
            address_ == _address[0xA9] || 
            address_ == _address[0xAB]
        );
        uint256 previousTime;
        if (_locked[address_] == 0) {
            require(timestamp_ > block.timestamp, "15");
            _locked[address_] = timestamp_;
            Total.lockedAccounts += 1;
        } else {
            require(timestamp_ > _locked[address_], "26");
            previousTime = _locked[address_];
            _locked[address_] = timestamp_;
        }
        if (address_ == _address[0xAB]) {
            Bool.liquidityLocked = true;
            emit LiquidityLockSet(address_, previousTime, _locked[address_]);
        } else {
            emit LockSet(address_, previousTime, _locked[address_]);
        }
    }

    /// @dev returns locks timestamps
    function getLockTimes() external view returns(uint256, uint256, uint256, uint256) {
        return (
            _locked[_address[0xA6]],
            _locked[_address[0xA8]],
            _locked[_address[0xA9]],
            _locked[_address[0xAB]]
        );
    }

    /**
     *  @dev returns lock state of an account
     *  @param address_ address
     *  @return bool locked
     */
    function isAccountLocked(
        address address_
    ) public view returns(bool) {
        return (_locked[address_] > 0) ? true : false;
    }

    /** 
     *  @dev returns account lock timestamp
     *  @param address_ address
     *  @return uint256 timestamp
     */
    function accountIsLockedUntil(
        address address_
    ) external view returns(uint256) {
        return _locked[address_];
    }

    /**
     *  @dev returns lock state of LP provider address
     *  @return bool locked
     */
    function isLiqudityLocked() public view returns(bool) {
        return _locked[_address[0xAB]] == 0 ? false : true;
    }

    /**
     *  @dev returns LP lock timestamp
     *  @return uint256 timestamp
     */
    function liqudityIsLockedUntil() external view returns(uint256) {
        return _locked[_address[0xAB]];
    }

    /**
     *  @dev toggles fees enabled/disabled
     *  @notice Emits:
     *      {FeesEnabled} bool
     */
    function toggleFeesEnabled() external onlyOwner {
        Bool.feesEnabled = !Bool.feesEnabled;
        emit FeesEnabled(Bool.feesEnabled);
    }

    /**
     *  @dev toggles limits enabled/disabled
     *  @notice Emits:
     *      {LimitsEnabled} bool
     */
    function toggleLimitsEnabled() external onlyOwner {
        Bool.limitsEnabled = !Bool.limitsEnabled;
        emit LimitsEnabled(Bool.limitsEnabled);
    }

    /**
     *  @dev toggles automatic processing of collected fees
     *  @notice Emits:
     *      {AutoSwapEnabled} bool
     */
    function toggleSwapEnabled() external onlyOwner {
        Bool.swapEnabled = !Bool.swapEnabled;
        emit AutoSwapEnabled(Bool.swapEnabled);
    }

    /**
     *  @dev toggles automatic distribution of collected fees
     *  @notice Emits:
     *      {AutoDistributeFeesEnabled} bool
     */
    function toggleAutoDistributeFees() external onlyOwner {
        Bool.autoDistributeFees = !Bool.autoDistributeFees;
        emit AutoDistributeFeesEnabled(Bool.autoDistributeFees);
    }

    /**
     *  @dev sets tax percentage of specific tax by index_
     *  @param index_ bytes1
     *  @param percent_ uint256 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Required:
     *      - index_ must still be in effect (we are not in post burn era)
     *      - tax percentage has to be different from current
     *      - tax percentage for treasury tax has to be less or equal to 8% (800)
     *      - total sell or burn tax has to be less or equal to 15% (1500)
     *  @notice Emits:
     *      {TaxSet} index_ bytes1, percent_ uint256, bool enabled
     */
    function setTaxPercentage(
        bytes1 index_, 
        uint256 percent_
    ) external onlyOwner {
        applies(index_);
        require(Tax[index_].percent != percent_, "09");
        uint256 percent = percent_ > 0 ? percent_ : 0;
        Tax[index_].previousPercent = Tax[index_].percent;
        Tax[index_].previousState = Tax[index_].enabled;
        Tax[index_].enabled = percent > 0 ? true : false;
        Tax[index_].percent = Tax[index_].enabled ? percent : 0;
        if (index_ == 0xA2) {
            require(percent <= 800, "07");
            Total.baseTax = Tax[0xA2].percent;          
        }
        Total.sellTax = Total.baseTax + Tax[0xA0].percent;
        Total.buyTax = Total.baseTax + Tax[0xA1].percent;
        require(Total.sellTax <= 1500 && Total.buyTax <= 1500, "17");
        emit TaxSet(index_, percent_, Tax[index_].enabled);
    }

    /**
     *  @dev Other networks will not "know" if it's enabled or disabled.
     *      We need ability to disable or re-enable autobuybackandburn.
     *  @notice If something goes wrong it can also be turned on/off
     *      manually by the contract owner, but can be re-enabled only on main net;
     *      it will be auto disabled if total supply is equal or less then max burn
     *  @notice Requires if value_ is true:
     *      - Total of burned tokens must be less than Max.burn var
     *      - isMainNet is true eg. we have to be on ethereum mainnet
     *  @notice Emits:
     *      {AutoBuyBackAndBurnEnabled} bool value_
     */
    function setAutoBuyBackAndBurn(
        bool value_
    ) external onlyOwner {
        if (value_) {
            require(Total.burned < Max.burn, "18");
            require(Bool.isMainNet, "19");
            Tax[0xA0].enabled = Tax[0xA0].previousState;
            Tax[0xA0].percent = Tax[0xA0].previousPercent;
            Tax[0xA1].enabled = Tax[0xA1].previousState;
            Tax[0xA1].percent = Tax[0xA1].previousPercent;
            Bool.buyBack = true;
        }
        if (!value_ && Bool.buyBack) {
            cleanUpAndEndTheBurn();
        }
        emit AutoBuyBackAndBurnEnabled(value_);
    }

    /**
     *  @dev check is AutoBuyBackAndBurn is Enabled
     *  @return bool
     */
    function isBuyBackAndBurnEnabled() external view returns(bool) {
        return Bool.buyBack;
    }

    /**
     *  @param index_ bytes1
     *  @param threshold_ uint256, token amount threshold
     *  @param ethThreshold bool, if true eth threshold will be set
     *  @notice Requires:
     *      - index_ must still be in effect (we are not in post burn era)
     *      - amount_ must be different than current threshild
     *  @notice Emits:
     *      {NewThresholdSet} bytes1 index, uint256 previous, uint256 amount
     */
     /// @dev be carefull not to set the threshold too low on mainnet
    function setThreshold(
        bytes1 index_, 
        uint256 threshold_, 
        bool ethThreshold
    ) external onlyOwner {
        applies(index_);
        require(index_ >= 0xA0 && index_ <= 0xA3, "25");
        uint256 previous;
        if (ethThreshold) {
            require(Tax[index_].ethThreshold != threshold_, "09");
            previous = Tax[index_].ethThreshold;
            Tax[index_].ethThreshold = threshold_;
        } else {
            require(Tax[index_].sirThreshold != threshold_, "09");
            previous = Tax[index_].sirThreshold;
            Tax[index_].sirThreshold = threshold_;
        }
        emit NewThresholdSet(index_, previous, threshold_, ethThreshold);
    }

    /**
     *  @dev Check if an account is excluded from paying taxes.
     *  @param address_ address
     *  @return boolean
     */
    function isExcludedFromFee(
        address address_
    ) external view returns(bool) {
        return ExcludedFromFee.contains(address_);
    }

    /**
     *  @dev Check if an account is excluded from max transacion limit.
     *  @param address_ address
     *  @return boolean
     */
    function isExcludedFromMaxTx(
        address address_
    ) external view returns(bool) {
        return ExcludedFromMaxTx.contains(address_);
    }

   /**
     *  @dev Sets an address of account by index (lookup Keys).
     *  @notice if an address is locked then the lock timestamp will be 
     *  transferred to new address
     *  @param index_ bytes1
     *  @param address_ standard address
     *  @notice Required:
     *      - ValidAddress(address_) non 0 address
     *      - valid index_ (lookup Keys)
     *      - address_ is different from stored one.
     *  @notice Emits:
     *      {AddressSet} bytes1 index, address previous, address _address
     */
    function setAddress(
        bytes1 index_,
        address address_
    ) external onlyOwner {
        validAddress(address_);
        require(index_ >= 0xA0 && index_ <= 0xAC, "25");
        require(_address[index_] != address_, "09");
        address previousAddress = _address[index_];
        if (_balances[previousAddress] > 0) {
            moveBalance(previousAddress, address_);
        }
        _address[index_] = address_;
        if (isAccountLocked(previousAddress)) {
            setLock(_address[index_], _locked[previousAddress]);
            setLock(previousAddress, 0);
        }
        emit AddressSet(index_, previousAddress, address_);
    }

    /**
     *  @dev Sets maximum sell amount in percent.
     *  @param percent_ uint256 max sell in percent of liquidity.
     *  @notice Reqired: 
     *      - percent_ 100 to 1000 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Emits: 
     *      {MaxSellPercentChanged} uint256 previous, uint256 percent.
     */
    function setMaxSellAmountPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 100 && percent_ <= 1000, "20");
        uint256 previous = Max.sellPercent;
        Max.sellPercent = percent_;
        emit MaxSellPercentChanged(previous, percent_);
    }

    /**
     *  @dev Sets maximum buy amount in percent.
     *  @param percent_ uint256 max sell in percent of liquidity.
     *  @notice Reqired: 
     *      - percent_ 100 to 1000 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Emits: 
     *      {MaxBuyPercentChanged} uint256 previous, uint256 percent.
     */
    function setMaxBuyAmountPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 100 && percent_ <= 1000, "20");
        uint256 previous = Max.buyPercent;
        Max.buyPercent = percent_;
        emit MaxBuyPercentChanged(previous, percent_);
    }

    /// @dev returns maximum amount of tokens that can be sold in a transaction
    function getMaxSellAmount() external view returns(uint256) {
        return Max.sellAmount.div(_multiplier);
    }

    /// @dev returns maximum amount of tokens that can be sold in a transaction
    function _getMaxSellAmount() private view returns(uint256) {
        (uint256 count,) = _getReserves();
        return count.mul(Max.sellPercent).div(1e4);
    }

    /// @dev returns maximum amount of tokens that can be bought in a transaction
    function getMaxBuyAmount() external view returns(uint256) {
        return Max.buyAmount.div(_multiplier);
    }

    /// @dev returns maximum amount of tokens that can be bought in a transaction
    function _getMaxBuyAmount() private view returns(uint256) {
        (uint256 count,) = _getReserves();
        return count.mul(Max.buyPercent).div(1e4);
    }

    /// @dev returns maximum amount of tokens that can be transferred from wallet to wallet
    function getMaxTransactionAmount() external view returns(uint256) {
        return Max.txAmount.div(_multiplier);
    }

    /// @dev returns maximum amount of tokens that can be transferred from wallet to wallet
    function _getMaxTransactionAmount() private view returns(uint256) {
        return Total.supply.mul(Max.txPercent).div(1e4);
    }

    /// @dev returns data of Total struct
    function getTotals() external view returns(Totals memory) {
        return Total;
    }
    
    /// @dev returns data of Bool struct
    function getBooleans() external view returns(Booleans memory) {
        return Bool;
    }

    /// @dev returns data of Max struct
    function getMaxValues() external view returns(MaxVal memory) {
        return Max;
    }

    /**
     *  @dev returns data stored in Tax struct, by index
     *  @param index_ bytes1
     *  @return Taxes memory
     */
    function getTaxData(
        bytes1 index_
    ) external view returns(Taxes memory) {
        return Tax[index_];
    }

    /**
     *  @dev Sets maximum transaction amount in percent.
     *  @param percent_ uint256 max sell in percent of liquidity.
     *  @notice Reqired: 
     *      - percent_ 1 to 10 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Emits: 
     *      {MaxTransactionChanged} uint256 previous percent, uint256 percent, previous Amount, new Amount
     */
    function setMaxTransactionPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 100 && percent_ <= 1000, "20");
        uint256 previousPercent = Max.txPercent;
        uint256 previousAmount = Max.txAmount;
        Max.txPercent = percent_;
        Max.txAmount = _getMaxTransactionAmount();
        emit MaxTransactionChanged(previousPercent, Max.txPercent, previousAmount, Max.txAmount);
    }

    /**
     *  @param address_ address
     *  @param amount_ uint256
     *  @notice Required: 
     *      - non 0 or dead address
     *      - amount_ > 0
     *      - Total airdropped + amount has to be less than max total airdropped
     *      - isMainNet must be False
     *      - address_ wasn't used previously
     *  @notice Emits:
     *      {Airdroped} address _address, uint256 amount
     */
    function airdrop(
        address address_,
        uint256 amount_
    ) external onlyOwner {
        validAddress(address_);
        require(amount_ > 0, "00");
        require(Total.airdropped + amount_ <= Max.airdrop, "22");
        require(!Bool.isMainNet, "19");
        require(!Airdrops.contains(address_), "24");
        Total.airdropped += amount_;
        Airdrops.add(address_);
        transferBalance(_address[0xAA], address_, amount_);
        emit Airdroped(address_, amount_);
    }

    /**
     *  @dev buys tokens, with ETH on contract balance, and burns them.
     *  When amount of burned tokens reaches Max.burned limit, this function 
     *  is no longer used.
     *  @notice Emits:
     *      {BoughtBackAndBurned} uint256 eAmount eth, uint256 tAmount tokens
     */
    function _buyBackAndBurn() private lockTheSwap {
        uint256 eAmount = Tax[0xA0].ethBalance;
        Tax[0xA2].ethBalance = 0;
        if (Total.burned >= Max.burn && Bool.buyBack) {
            cleanUpAndEndTheBurn();
        } else {
            Total.buyback += eAmount;
            _swapEthForTokens(_address[0xA3], eAmount);
            uint256 diff;
            uint256 tAmount = _balances[_address[0xA3]];
            if (tAmount > 0) {
                uint256 burned = Total.burned + tAmount;
                if (burned > Max.burn) {
                    diff = burned - Max.burn;
                    tAmount -= diff;
                }
                __burn(_address[0xA3], tAmount);
                if (Total.burned == Max.burn) {
                    cleanUpAndEndTheBurn();
                }
                if (diff > 0) {
                    transferBalance(_address[0xA0], _address[0xA2], diff);
                }
                emit BoughtBackAndBurned(eAmount, tAmount);
            }
        }
    }

    /**
     *  @dev swap tokens to eth
     *  @param amount_ uint256 amount
     *  @return amount uint256 of new converted eth
     */
    function _swapTokensForEth(
        uint256 amount_
    ) private lockTheSwap returns(uint256) {
        uint256 previousBalance = address(this).balance;
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = _address[0xB1];
        _approve(address(this), _address[0xB2], amount_);
        _dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            amount_, 0, path, address(this), block.timestamp + 60000
        );
        return address(this).balance.sub(previousBalance);
    }

    /**
     *  @dev swap ethers to tokens
     *  @param to_ address
     *  @param amount_ uint256 amount
     */
    function _swapEthForTokens(
        address to_,
        uint256 amount_
    ) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = _address[0xB1];
        path[1] = address(this);
        _dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount_}(
            0, path, to_, block.timestamp + 60000
        );
    }

    /**
     *  @dev returns address by index
     *  @param index_ bytes1 (lookup indexes)
     *  @return address
     */
    function getAddress(
        bytes1 index_
    ) external view returns(address) {
        return index_ <= 0xB4 ? _address[index_] : address(0);
    }

    /**
     *  @dev clean up after end of burn
     *  @notice Required:
     *      - buyBack has to be enabled 
     */
    function cleanUpAndEndTheBurn() private {
        require(Bool.buyBack, "21");
        moveBalance(_address[0xA0], _address[0xA2]);
        moveBalance(_address[0xA1], _address[0xA2]);
        moveBalance(_address[0xA3], _address[0xA2]);
        Tax[0xA0].enabled = false;
        Tax[0xA1].enabled = false;
        Bool.buyBack = false;
        Bool.limitsEnabled = false;
        emit BurnEnded(block.timestamp, block.number);
    }

    /// @dev checks it trading enabled
    function isTradingEnabled() external view returns(bool) {
        return Bool.isTradingEnabled;
    }

    /// @dev returns state of lp (token, eth)
    function _getReserves() public view returns(uint256, uint256) {
        return UniswapV2Library.getReserves(_dexRouter.factory(), address(this), _address[0xB1]);
    }

    /// @dev returns address of liquidity pool
    function getLiquidityPoolAddress() public view returns(address) {
        return UniswapV2Library.pairFor(_address[0xB4], _address[0xB1], address(this));
    }

    /**
     *  @dev mints tokens to address
     *  @param address_ address
     *  @param amount_ amount
     *  @notice Required:
     *      - current total supply has to be less than initial supply
     *  @notice Emits:
     *      {Minted} address_ to, amount_ amount
     *      {Transfer} address_ from, address_ to, amount_ tokens
     */
    function __mint(
        address address_,
        uint256 amount_
    ) private {
        Total.supply += amount_;
        require(Total.supply <= _initialSupply, "22");
        _balances[address_] += amount_;
        emit Minted(address_, amount_);
        emit Transfer(address(0), address_, amount_);
    }

    /**
     *  @dev burns tokens from address
     *  @param from_ address
     *  @param amount_ amount
     *  @notice Required:
     *      - Total.burned + amount_ has to be less or equal to Max burn
     *      - amount has to be less or equal to balance
     */
    function burn(
        address from_, 
        uint256 amount_
    ) external onlyOwner {
        require(Total.burned + amount_ <= Max.burn, "22");
        require(amount_ <= _balances[from_], "05");
        __burn(from_, amount_);
    }

    /**
     *  @dev burns tokens from address
     *  @param address_ address
     *  @param amount_ amount
     *  @notice Emits:
     *      {Burned} address_ address, amount_ amount
     *      {Transfer} address_ from, address_ to, amount_ tokens
     */
    function __burn(
        address address_,
        uint256 amount_
    ) private {
        unchecked {
            _balances[address_] -= amount_;   
        }
        _balances[DEAD] += amount_;
        Total.burned += amount_;
        Total.supply -= amount_;
        Tax[0xA0].ethBalance = 0;
        IUniswapV2Pair(_dexPair).sync();
        Max.txAmount = _getMaxTransactionAmount();
        emit Burned(address_, amount_);
        emit Transfer(address_, DEAD, amount_);
    }

    /// @dev adds liquidity
    function _addLiquidity() private lockTheSwap {
        uint256 e = Tax[0xA1].ethBalance;
        Tax[0xA1].ethBalance = 0;
        uint256 b = _balances[_address[0xAC]];
        moveBalance(_address[0xAC], address(this));
        _approve(address(this), _address[0xB2], b);
        (uint256 t1, uint256 e1,) = _dexRouter.addLiquidityETH{value : e} (
            address(this), b, 0, 0, _owner, block.timestamp + 60000
        );
        Total.liquidatedTokens += t1;
        Total.liquidatedEthers += e1;
        Max.sellAmount = _getMaxSellAmount();
        Max.buyAmount = _getMaxBuyAmount();
        emit AddedLiquidity(e, b);
    }

    /**
     *  @dev Add eAmount_ of ETH and tAmount_ of tokens to the LP.
     *  Depends on the current rate for the pair between this token and WETH,
     *  eAmount_ and tAmount_ might not match perfectly.
     *  Dust(leftover) ETH or token will be refunded to this contract
     *  (usually very small quantity).
     *  @param eAmount_ uint256
     *  @param tAmount_ uint256
     *  @notice Required:
     *      - eth balance must be greater or equal to amount
     *      - token balance must be greater or equal to amount
     */
    function addLiquidity(
        uint256 eAmount_,
        uint256 tAmount_
    ) external onlyOwner {
        require(address(this).balance >= eAmount_, "16");
        require(_balances[_address[0xAC]] >= tAmount_, "05");
        _addLiquidity();
    }

    /**
     *  @dev transfer amount of tokens from_ address to to_ address
     *  @param from_ address
     *  @param to_ address
     *  @notice Emits:
     *      {Transfer} from_ address, to_ address, amount_ uint256
     */
    function moveBalance(
        address from_, 
        address to_
    ) private { 
        uint256 amount_ = _balances[from_];
        _balances[from_] = 0;
        _balances[to_] += amount_;
        emit Transfer(from_, to_, amount_);
    }

    /**
     *  @dev transfer amount of tokens from_ address to to_ address
     *  @param from_ address
     *  @param to_ address
     *  @param amount_ uint256
     *  @notice Emits:
     *      {Transfer} from_ address, to_ address, amount_ uint256
     */
    function transferBalance(
        address from_, 
        address to_, 
        uint256 amount_
    ) private {
        unchecked {
            _balances[from_] -= amount_;
            _balances[to_] += amount_;   
        }
        emit Transfer(from_, to_, amount_);
    }

    /// @dev recover ethers stuck on proxy
    function recoverETHFromProxy() external onlyOwner {
        proxy.sendEth();
    }

    /// @dev recovers Tokens stuck on proxy
    function recoverTokensFromProxy() external onlyOwner {
        moveBalance(_address[0xA3], _address[0xA2]);
    }

    /**
     *  @dev withdraw non-native tokens sent to contract address
     *  @param token_ address
     *  @param amount_ uint256
     *  @param senderAddress_ address
     *  @notice Required:
     *      - token address is not native token address
     *      - onlyOwner
     *  @notice Emits:
     *      {WithdrawnERC20} token_ address, senderAddress_ address, amount_ uint256
     */
    function withdrawTokenERC20(
        address token_,
        uint256 amount_,
        address senderAddress_
    ) external onlyOwner {
        require(token_ != address(this), "23");
        IERC20(token_).transfer(_owner, amount_);
        emit WithdrawnERC20(token_, senderAddress_, amount_);
    }

    /**
     *  @dev withdraw surplus ETH if any
     *  @param address_ address to
     */
    function withdrawETH(
        address address_
    ) external onlyOwner {
        uint256 sBalance = address(this).balance.sub(
            Tax[0xA0].ethBalance + 
            Tax[0xA1].ethBalance + 
            Tax[0xA2].ethBalance
        );
        if (sBalance > 1 ether) {
            payable(address_).transfer(sBalance);
            emit WithdrawnETH(address_, sBalance);
        }
    }

    /**
     *  @dev check if tax is in use - burn era
     *  @param index_ bytes1
     */
    function applies(
        bytes1 index_
    ) private view { 
        if (index_ == 0xA0 || index_ == 0xA1) {
            require(Bool.buyBack, "03");
        }
    }

    /**
     *  @dev cheks if an address is locked and unlocks if time has expired
     *  @param address_ address
     *  @return bool
     *  @notice Emits:
     *      {LiquidityUnlocked} address, timestamp
     *      or
     *      {AccountUnlocked} address, timestamp
     */
    function _checkLock(
        address address_
    ) private returns(bool) {
        if (_locked[address_] == 0) {
            return false;
        }
        if (_locked[address_] < block.timestamp) {
            _locked[address_] = 0;
            if (address_ == _address[0xAB]) {
                Bool.liquidityLocked = false;
                emit LiquidityUnlocked(address_, block.timestamp);
            } else {
                emit AccountUnlocked(address_, block.timestamp);
            }
            if (Total.lockedAccounts > 0) {
                Total.lockedAccounts -= 1;
            }
            return false;
        }
        return true;
    }

    /**
     *  @dev unlocks an address if timer has expired
     *  @param address_ address
     */
    function unlock(
        address address_
    ) external onlyOwner {
        _checkLock(address_);
    }

    /**
     *  @dev returns token and eth balances of tax addresses
     */
        function getTaxBalances() external view returns(
        uint256, uint256, uint256, 
        uint256, uint256, uint256, 
        uint256, uint256, uint256
    ) {
        return (
            address(this).balance,
            Tax[0xA0].ethBalance,
            Tax[0xA1].ethBalance,
            Tax[0xA2].ethBalance,
            _balances[address(this)],
            _balances[_address[0xA0]],
            _balances[_address[0xA1]],
            _balances[_address[0xAC]],
            _balances[_address[0xA2]]
        );
    }

    /**
     *  @dev check if router is Uniswap because we burn only on Uniswap
     *  @return bool
     */
    function isRouterUniswap() private view returns(bool) {
        return _address[0xB2] == address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D) ? true : false;
    }
    
    /**
     *  @dev check if an address is valid 
     *  @param address_ address
     *  @notice Required:
     *      - address should not be 0 or DEAD
     */
    function validAddress(
        address address_
    ) private pure {
        require(address_ != address(0) && address_ != DEAD, "01");
    }
}

pragma solidity >=0.6.2;

import './IUniswapV2Router01.sol';

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";
import "../extensions/draft-IERC20Permit.sol";
import "../../../utils/Address.sol";

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)

pragma solidity ^0.8.0;

/**
 * @dev Library for managing
 * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
 * types.
 *
 * Sets have the following properties:
 *
 * - Elements are added, removed, and checked for existence in constant time
 * (O(1)).
 * - Elements are enumerated in O(n). No guarantees are made on the ordering.
 *
 * ```
 * contract Example {
 *     // Add the library methods
 *     using EnumerableSet for EnumerableSet.AddressSet;
 *
 *     // Declare a set state variable
 *     EnumerableSet.AddressSet private mySet;
 * }
 * ```
 *
 * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
 * and `uint256` (`UintSet`) are supported.
 *
 * [WARNING]
 * ====
 *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.
 *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
 *
 *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.
 * ====
 */
library EnumerableSet {
    // To implement this library for multiple types with as little code
    // repetition as possible, we write it in terms of a generic Set type with
    // bytes32 values.
    // The Set implementation uses private functions, and user-facing
    // implementations (such as AddressSet) are just wrappers around the
    // underlying Set.
    // This means that we can only create new EnumerableSets for types that fit
    // in bytes32.

    struct Set {
        // Storage of set values
        bytes32[] _values;
        // Position of the value in the `values` array, plus 1 because index 0
        // means a value is not in the set.
        mapping(bytes32 => uint256) _indexes;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function _add(Set storage set, bytes32 value) private returns (bool) {
        if (!_contains(set, value)) {
            set._values.push(value);
            // The value is stored at length-1, but we add 1 to all indexes
            // and use 0 as a sentinel value
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function _remove(Set storage set, bytes32 value) private returns (bool) {
        // We read and store the value's index to prevent multiple reads from the same storage slot
        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {
            // Equivalent to contains(set, value)
            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
            // the array, and then remove the last element (sometimes called as 'swap and pop').
            // This modifies the order of the array, as noted in {at}.

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastValue = set._values[lastIndex];

                // Move the last value to the index where the value to delete is
                set._values[toDeleteIndex] = lastValue;
                // Update the index for the moved value
                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
            }

            // Delete the slot where the moved value was stored
            set._values.pop();

            // Delete the index for the deleted slot
            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function _contains(Set storage set, bytes32 value) private view returns (bool) {
        return set._indexes[value] != 0;
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function _length(Set storage set) private view returns (uint256) {
        return set._values.length;
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function _at(Set storage set, uint256 index) private view returns (bytes32) {
        return set._values[index];
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function _values(Set storage set) private view returns (bytes32[] memory) {
        return set._values;
    }

    // Bytes32Set

    struct Bytes32Set {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _add(set._inner, value);
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
        return _remove(set._inner, value);
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
        return _contains(set._inner, value);
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(Bytes32Set storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
        return _at(set._inner, index);
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
        return _values(set._inner);
    }

    // AddressSet

    struct AddressSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(AddressSet storage set, address value) internal returns (bool) {
        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(AddressSet storage set, address value) internal returns (bool) {
        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(AddressSet storage set, address value) internal view returns (bool) {
        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    /**
     * @dev Returns the number of values in the set. O(1).
     */
    function length(AddressSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(AddressSet storage set, uint256 index) internal view returns (address) {
        return address(uint160(uint256(_at(set._inner, index))));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(AddressSet storage set) internal view returns (address[] memory) {
        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }

    // UintSet

    struct UintSet {
        Set _inner;
    }

    /**
     * @dev Add a value to a set. O(1).
     *
     * Returns true if the value was added to the set, that is if it was not
     * already present.
     */
    function add(UintSet storage set, uint256 value) internal returns (bool) {
        return _add(set._inner, bytes32(value));
    }

    /**
     * @dev Removes a value from a set. O(1).
     *
     * Returns true if the value was removed from the set, that is if it was
     * present.
     */
    function remove(UintSet storage set, uint256 value) internal returns (bool) {
        return _remove(set._inner, bytes32(value));
    }

    /**
     * @dev Returns true if the value is in the set. O(1).
     */
    function contains(UintSet storage set, uint256 value) internal view returns (bool) {
        return _contains(set._inner, bytes32(value));
    }

    /**
     * @dev Returns the number of values on the set. O(1).
     */
    function length(UintSet storage set) internal view returns (uint256) {
        return _length(set._inner);
    }

    /**
     * @dev Returns the value stored at position `index` in the set. O(1).
     *
     * Note that there are no guarantees on the ordering of values inside the
     * array, and it may change when more values are added or removed.
     *
     * Requirements:
     *
     * - `index` must be strictly less than {length}.
     */
    function at(UintSet storage set, uint256 index) internal view returns (uint256) {
        return uint256(_at(set._inner, index));
    }

    /**
     * @dev Return the entire set in an array
     *
     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
     * this function has an unbounded cost, and using it as part of a state-changing function may render the function
     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
     */
    function values(UintSet storage set) internal view returns (uint256[] memory) {
        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        /// @solidity memory-safe-assembly
        assembly {
            result := store
        }

        return result;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)

pragma solidity ^0.8.0;

// CAUTION
// This version of SafeMath should only be used with Solidity 0.8 or later,
// because it relies on the compiler's built in overflow checks.

/**
 * @dev Wrappers over Solidity's arithmetic operations.
 *
 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler
 * now has built in overflow checking.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     *
     * _Available since v3.4._
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     *
     * _Available since v3.4._
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator.
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {trySub}.
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b <= a, errorMessage);
            return a - b;
        }
    }

    /**
     * @dev Returns the integer division of two unsigned integers, reverting with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a / b;
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * reverting with custom message when dividing by zero.
     *
     * CAUTION: This function is deprecated because it requires allocating memory for the error
     * message unnecessarily. For custom revert reasons use {tryMod}.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(
        uint256 a,
        uint256 b,
        string memory errorMessage
    ) internal pure returns (uint256) {
        unchecked {
            require(b > 0, errorMessage);
            return a % b;
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.1;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)

pragma solidity ^0.8.0;

/**
 * @title Counters
 * @author Matt Condon (@shrugs)
 * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
 * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 *
 * Include with `using Counters for Counters.Counter;`
 */
library Counters {
    struct Counter {
        // This variable should never be directly accessed by users of the library: interactions must be restricted to
        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
        // this feature: see https://github.com/ethereum/solidity/issues/4637
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {
        return counter._value;
    }

    function increment(Counter storage counter) internal {
        unchecked {
            counter._value += 1;
        }
    }

    function decrement(Counter storage counter) internal {
        uint256 value = counter._value;
        require(value > 0, "Counter: decrement overflow");
        unchecked {
            counter._value = value - 1;
        }
    }

    function reset(Counter storage counter) internal {
        counter._value = 0;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}