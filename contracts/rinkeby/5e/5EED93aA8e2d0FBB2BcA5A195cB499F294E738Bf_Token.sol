// SPDX-License-Identifier: MIT

/* 

On est le 5 septembre et câ€™est une date importante pour toi, car câ€™est 
le jour oÃ¹ tu es nÃ©. DÃ¨s ta naissance, tu as propagÃ© de la joie autour 
de toi, que ce soit Ã  ta mÃ¨re, Ã  ton pÃ¨re ou Ã  ta grand-mÃ¨re. Ce sont 
trois personnes qui comptent pour toi et qui, peu importe les choix et 
directions de ta vie, seront toujours lÃ  pour toi, câ€™est une vraie chance que tu mÃ©rites. Mais aujourdâ€™hui, câ€™est la premiÃ¨re annÃ©e que tu vas passer loin dâ€™eux et de tes amis puisque tu vas dÃ©couvrir ta nouvelle vie Ã  Paris, dans une des meilleures Ã©coles dâ€™ingÃ©nieur de France. Qui lâ€™eut cru ? Qui aurait pu croire que le petit Hugo qui jouait au foot avec son pÃ¨re au fin fond de Parempuyre Ã  cÃ´tÃ© dâ€™une famille de gitans finirait par en arriver lÃ  ? Ã€ vrai dire, tout le monde aurait pu le croire, car tu as toujours eu cette volontÃ© dâ€™aller au bout de chaque chose que tu entreprends. Je peux maintenant tâ€™avouer que je rÃªvais de tâ€™avoir comme binÃ´me pour mes projets dâ€™Ã©tudes puisquâ€™on est tout autant perfectionniste que travailleur. Je pense sincÃ¨rement que si tu avais Ã©tÃ© dans mon Ã©cole, tu aurai Ã©galement pu Ãªtre un des meilleurs, juste derriÃ¨re moi (bien sÃ»r) car ton anglais câ€™est pas encore Ã§a ðŸ˜‰ mais je reste persuadÃ©e du potentiel que tu as.

Tu as 21 ans, et tu as presque tout pour tâ€™Ã©panouir, un nouveau dÃ©part avec de nouvelles personnes, une filiÃ¨re qui va te permettre dâ€™accÃ©der au mÃ©tier qui te plaÃ®t, une colocation qui va probablement te faire vivre de merveilleux souvenirs, sans oublier tes passes temps, comme la salle de sport, ton entreprise eBay ou encore le foot. Tout sâ€™est alignÃ© comme tu lâ€™as voulu, sauf moi. Dans toute ta vie, jâ€™ai Ã©tÃ© principalement ton bonheur, mais surtout ta dÃ©ception, notre dÃ©ception. Comme lâ€™a dit Coldplay dans sa musique Â« the scientist Â», â€œitâ€™s such a shame for us to partâ€, car jamais je ne pouvais imaginer ma vie sans toi. Trouver un Ãªtre qui te comprend et avec qui tu es toi-mÃªme, ce nâ€™est pas donnÃ© Ã  tout le monde. On a les mÃªmes centres dâ€™intÃ©rÃªts, jâ€™aime le foot, clash royal, call of, fortnite, minecraft, youtube, la crypto, le commerce, la sociabilitÃ©, les voyagesâ€¦ Bon jâ€™avoue il manquait plus que tu aimes les sÃ©ries et tu aurais Ã©tÃ© parfait. Je veux encore faire plein de chose avec toi, Je veux continuer de fumer devant Rick et morty, de faire du foot ou mÃªme jouer Ã  fifa avec toi, dâ€™aller au cinÃ© pour voir le prochain dessin annimÃ© les Mignons, de vivre cette prochaine coupe du monde avec toi, de te battre a clash royale, de faire nos soirÃ©es champagnes, de te raconter tout les potins que jâ€™apprends et dieux sait que jâ€™ai appris des dingueries, de voyager, de constamment te surprendre avec de nouveaux outfit, de ne toujours pas te croire que tu connais bien bordeaux, de tâ€™embÃªter quand tu as vraiment pas envie de me faire des chatouilles, de voir Neta tâ€™aimer plus que moi, de te dire que tâ€™es minus ou que tâ€™as ocho aÃ±o, de te faire les nouvelles recettes que jâ€™apprends, de dÃ©penser des sous dans nos soirÃ©e casino avec quentin, de pÃªcher des crabes ou toute sorte de crustacÃ©s, de dÃ©corer notre appartement, dâ€™avoir les mÃªmes chaussures que toi, dâ€™Ãªtre le plus mignon des couples Ã  chaque soirÃ©e, dâ€™Ãªtre ton coussin moelleux, dâ€™Ãªtre tout simplement ta moitiÃ©. Il nous reste encore tellement de chose Ã  vivre et la vie est si courte que je ne peux me permettre de te laisser partir sans rien faire. Jâ€™ai le sentiment profond que notre relation est inachevÃ©e et quâ€™il nous reste encore Ã©normÃ©ment de moment de bonheur Ã  vivre ensemble.

Alors voilÃ , on est le 5 septembre et la seule chose que je dÃ©teste plus que tout, câ€™est le temps, car il te permet dâ€™oublier, dâ€™oublier Ã  quel point on Ã©tait bien ensemble, et quâ€™on aimait le moindre dÃ©tail de lâ€™autre, dâ€™oublier quâ€™on Ã©tait seul contre tous et câ€™est pour Ã§a quâ€™on formait la meilleure des Ã©quipes, dâ€™oublier que la vie sans lâ€™autre en vaut tout simplement moins la peine. BientÃ´t un mois que je tâ€™attends, que jâ€™attends le jour oÃ¹ tu revoudras de moi, et que tu laisseras une derniÃ¨re chance au Â« nous Â» quâ€™on a pu crÃ©Ã© avec le temps. Peut-Ãªtre que maintenant, avec tous le recul que tu as pris, tu tâ€™ai rendu compte que ta vie est mieux sans moi, que je ne te manque pas comme tu me manques dans chaque chose que tu fais. Mais jâ€™ai espoir que ce quâ€™il y a entre nous est plus fort que lâ€™univers entier, et que dans une infime galaxie tu te dises : Â« Putain, elle a merdÃ© mais câ€™est elle qui me rend heureuxÂ». Je mâ€™en veux plus que tous et je pris pour que tu ai le courage de recommencer toute Ã  0.

Je veux continuer Ã  Ãªtre lÃ  pour tâ€™Ã©pauler et te pousser vers le haut car je sais Ã  quel point ces prochaines annÃ©es vont Ãªtre compliquÃ©es. Mais jâ€™ai aussi besoin que tu sois lÃ  pour moiâ€¦ Car câ€™est toi mon soleil au quotidien qui me donne le sourire. En plus dâ€™Ãªtre mon copain, tu Ã©tais mon meilleur ami... Tu es intelligent, intÃ©ressant, craquant, respectueux, taquin et drÃ´le, avec tes petits dÃ©fauts que je prends, car ils nâ€™ont jamais Ã©tÃ© volontaires. Je tâ€™ai pris pour ce que tu es, tes valeurs et ta droiture, qui ne peuvent que mâ€™obliger Ã  faire encore mieux et Ã  Ãªtre une meilleur personne. Je veux Ã©voluer et grandir Ã  tes cÃ´tÃ©s.
Je pourrais tâ€™Ã©crire encore des heures, mais je pense tâ€™avoir dit le plus important pour ce beau jour qui est ton anniversaire. Profite avec tes amis mecs, laisses les filles tranquilles et pense quâ€™au positif aujourdâ€™hui. Je tâ€™envois ces 1 million de JTM et jâ€™espÃ¨re que tu accepteras de me voir. Jâ€™ai trouvÃ© un restau Ã  Paris qui a lâ€™air fabuleux et jâ€™aimerais Ã©normÃ©ment tâ€™y invitÃ©. Je tâ€™aimes plus que tous. Emma B.


(ps : je lâ€™ai passÃ© trois fois au correcteur pour quâ€™il nâ€™y ai pas de faute car )


*/

pragma solidity ^0.8.7;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract Token is ERC20{
    constructor(uint256 NombreDeToken) ERC20("LoveNovAax", "JTM"){
        _mint(msg.sender,NombreDeToken);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)

pragma solidity ^0.8.0;

import "./IERC20.sol";
import "./extensions/IERC20Metadata.sol";
import "../../utils/Context.sol";

/**
 * @dev Implementation of the {IERC20} interface.
 *
 * This implementation is agnostic to the way tokens are created. This means
 * that a supply mechanism has to be added in a derived contract using {_mint}.
 * For a generic mechanism see {ERC20PresetMinterPauser}.
 *
 * TIP: For a detailed writeup see our guide
 * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
 * to implement supply mechanisms].
 *
 * We have followed general OpenZeppelin Contracts guidelines: functions revert
 * instead returning `false` on failure. This behavior is nonetheless
 * conventional and does not conflict with the expectations of ERC20
 * applications.
 *
 * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
 * This allows applications to reconstruct the allowance for all accounts just
 * by listening to said events. Other implementations of the EIP may not emit
 * these events, as it isn't required by the specification.
 *
 * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
 * functions have been added to mitigate the well-known issues around setting
 * allowances. See {IERC20-approve}.
 */
contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    string private _name;
    string private _symbol;

    /**
     * @dev Sets the values for {name} and {symbol}.
     *
     * The default value of {decimals} is 18. To select a different value for
     * {decimals} you should overload it.
     *
     * All two of these values are immutable: they can only be set once during
     * construction.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @dev Returns the name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @dev Returns the symbol of the token, usually a shorter version of the
     * name.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @dev Returns the number of decimals used to get its user representation.
     * For example, if `decimals` equals `2`, a balance of `505` tokens should
     * be displayed to a user as `5.05` (`505 / 10 ** 2`).
     *
     * Tokens usually opt for a value of 18, imitating the relationship between
     * Ether and Wei. This is the value {ERC20} uses, unless this function is
     * overridden;
     *
     * NOTE: This information is only used for _display_ purposes: it in
     * no way affects any of the arithmetic of the contract, including
     * {IERC20-balanceOf} and {IERC20-transfer}.
     */
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
     * `transferFrom`. This is semantically equivalent to an infinite approval.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * NOTE: Does not update the allowance if the current allowance
     * is the maximum `uint256`.
     *
     * Requirements:
     *
     * - `from` and `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     * - the caller must have allowance for ``from``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, allowance(owner, spender) + addedValue);
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        address owner = _msgSender();
        uint256 currentAllowance = allowance(owner, spender);
        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
        unchecked {
            _approve(owner, spender, currentAllowance - subtractedValue);
        }

        return true;
    }

    /**
     * @dev Moves `amount` of tokens from `from` to `to`.
     *
     * This internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `from` must have a balance of at least `amount`.
     */
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(from, to, amount);

        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;

        emit Transfer(from, to, amount);

        _afterTokenTransfer(from, to, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);

        _afterTokenTransfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        uint256 accountBalance = _balances[account];
        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
        unchecked {
            _balances[account] = accountBalance - amount;
        }
        _totalSupply -= amount;

        emit Transfer(account, address(0), amount);

        _afterTokenTransfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
     *
     * Does not update the allowance amount in case of infinite allowance.
     * Revert if not enough allowance is available.
     *
     * Might emit an {Approval} event.
     */
    function _spendAllowance(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        uint256 currentAllowance = allowance(owner, spender);
        if (currentAllowance != type(uint256).max) {
            require(currentAllowance >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, currentAllowance - amount);
            }
        }
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}

    /**
     * @dev Hook that is called after any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * has been transferred to `to`.
     * - when `from` is zero, `amount` tokens have been minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual {}
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

pragma solidity ^0.8.0;

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)

pragma solidity ^0.8.0;

import "../IERC20.sol";

/**
 * @dev Interface for the optional metadata functions from the ERC20 standard.
 *
 * _Available since v4.1._
 */
interface IERC20Metadata is IERC20 {
    /**
     * @dev Returns the name of the token.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the symbol of the token.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the decimals places of the token.
     */
    function decimals() external view returns (uint8);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}